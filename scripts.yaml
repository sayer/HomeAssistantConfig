store_bus:
  alias: Store Bus
  sequence:
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_pump
      - switch.heat
      - switch.air_conditioning
  - service: notify.notify
    data:
      message: Foretravel has been stored
      title: Foretravel Stored
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_autofill
      - switch.water_pump
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
  - delay:
      hours: 0
      minutes: 2
      seconds: 0
      milliseconds: 0
  - service: lock.lock
    data: {}
    target:
      entity_id: lock.locks
  - service: cover.close_cover
    data: {}
    target:
      entity_id: cover.all_night_shades
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Bus is being stored.
  - service: input_boolean.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: input_boolean.storage
  mode: single
good_night:
  alias: Good Night
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id: light.all_ceiling_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id: light.exterior_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
    action: light.turn_off
  - data: {}
    target:
      entity_id: lock.locks
    action: lock.lock
  - data: {}
    target:
      entity_id: cover.all_night_shades
    action: cover.close_cover
  - data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
    action: homeassistant.turn_on
  mode: single
good_morning:
  alias: Good Morning
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.dimmer_3_19
      - light.cockpit_accents
      - light.living_room_accents
      - light.rear_bath_accent
      - light.dimmer_3_10
      - light.entry_light_2
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 5
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - cover.windshield_night
      - cover.d_s_living_room_night
      - cover.dinette_night
    action: cover.open_cover
  mode: single
evening:
  alias: Evening
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.exterior_accents
      - light.interior_accents
      - light.porch_handle
      - light.awning_lights
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data: {}
    target:
      entity_id: cover.all_day_shades
    action: cover.close_cover
  mode: single
  icon: mdi:clock-time-seven
tv_time:
  alias: TV Time
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - service: light.turn_on
    data: {}
    target:
      entity_id:
      - light.interior_accents
    enabled: false
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.cockpit_accents
      - light.living_room_accents
  - service: cover.close_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.living_night_shades
  mode: single
  icon: mdi:television
drive_time:
  alias: Drive Time
  sequence:
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.cockpit_day_shades
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.exterior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 1
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.interior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_lights
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.water_autofill
      - switch.water_pump
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - media_player.tv_samsung_6_series_50
      - media_player.samsung_6_series_50
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - light.dimmer_3_14
      - light.entry_light_2
  - service: timer.start
    data: {}
    target:
      entity_id: timer.setlocationtimer
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Drive time!
  - service: input_boolean.turn_off
    metadata: {}
    data: {}
    target:
      entity_id:
      - input_boolean.storage
      - input_boolean.camping
  - service: switch.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: switch.ac_4
  mode: single
  icon: mdi:steering
all_bright:
  alias: All Bright
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 1
      seconds: 0
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id: light.all_lights
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.all_day_shades
      - cover.all_night_shades
  mode: single
  icon: mdi:weather-sunny
set_current_location_as_home:
  alias: Set Current location as home
  sequence:
  - condition: state
    entity_id: sensor.gps_127_0_0_1_latitude
    state: '{% if sensor.latitude | is_number %}'
    enabled: false
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    enabled: false
    action: homeassistant.set_location
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    action: homeassistant.set_location
  mode: single
notify_iphone:
  alias: Notify iPhone
  sequence:

  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    action: notify.notify
  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    action: notify.mobile_app_iphone_15_pro_max
  mode: single
  fields:
    title:
      selector:
        text:
      name: Title
      default: Foretravel
    message:
      selector:
        text:
      name: Message
tts_alert:
  alias: TTS alert
  sequence:
  - service: media_player.play_media
    target:
      entity_id:
      - media_player.kitchen
      - media_player.bedroom_2
    data:
      media_content_id: media-source://media_source/local/f1-radio-notification.mp3
      media_content_type: audio/mpeg
    metadata:
      title: f1-radio-notification.mp3
      thumbnail:
      media_class: music
      children_media_class:
      navigateIds:
      - {}
      - media_content_type: app
        media_content_id: media-source://media_source
  - service: tts.speak
    data:
      cache: true
      message: '{{message}}'
      media_player_entity_id: media_player.kitchen,media_player.bedroom_2
    target:
      entity_id: tts.piper
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
notify_home:
  alias: Notify Home
  sequence:
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.notify_iphone
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.tts_alert
  - data:
      title: '{{title}}'
      message: '{{message}}'
    action: notify.persistent_notification
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
      required: true
    title:
      selector:
        text:
      name: Title
      default: Foretravel
ai_analyze_dash_video:
  alias: AI - Analyze Dash Video
  sequence:
  - data:
      filename: /config/www/snapshot_dash.jpg
    action: camera.snapshot
    target:
      device_id: eea91240afc6576d615f0b18aa1ec28e
  - action: llmvision.stream_analyzer
    data:
      remember: false
      duration: 5
      max_frames: 3
      include_filename: false
      target_width: 1280
      detail: low
      max_tokens: 100
      temperature: 0.2
      expose_images: false
      provider: 01JDN5XHDWG1Q8TJ5718TYR6EE
      message: Analyze and describe the image. Highlight any people or vehicles. Keep
        the resonse to 128 characters.
      image_entity:
      - camera.g5_flex_high_resolution_channel
    response_variable: response
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data:
      message: 'Response received: {{ response.response_text }}'
    action: system_log.write
  - condition: template
    value_template: '{{ response.response_text is not none and response.response_text
      | length > 0 }}'
  - data:
      value: '{{ response.response_text }}'
    target:
      entity_id: input_text.llmvision_response
    action: input_text.set_value
  - action: notify.mobile_app_iphone_15_pro_max
    metadata: {}
    data:
      title: Foretravel - Dash
      message: '{{ response.response_text }}'
      data:
        image: http://192.168.100.175:8123/local/snapshot_dash.jpg
        content-type: image/jpeg
        hide-thumbnail: false
  description: Analyzes the dash video and updates input_text with the response.
  icon: mdi:cube-scan


lock_all_cargo_doors:
  alias: "Lock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.lock
              target:
                entity_id: lock.cargo_door_lock_all
      default:

        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_0
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_4

unlock_all_cargo_doors:
  alias: "Unlock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.unlock
              target:
                entity_id: lock.cargo_door_lock_all
      default:
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_0
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.unlock  
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_4

save_scene:
  alias: "Save Current Scene"
  description: "Saves the current state of all lights and shades as a scene with the given name"
  fields:
    scene_name:
      name: Scene Name
      description: Name to save this scene as
      required: true
      selector:
        text:
  sequence:
    # First, collect all light states, filtering out group entities
    - variables:
        all_light_states: "{{ states.light }}"
        # Filter out group entities by checking if they have an 'entity_id' attribute that contains a list of member entities
        light_entities: >-
          {% set filtered_lights = [] %}
          {% for entity_state in all_light_states %}
            {% if entity_state.attributes is defined %}
              {% set entity_id_attr = entity_state.attributes.entity_id %}
              {% if entity_id_attr is none or entity_id_attr is not iterable or entity_id_attr is string %}
                {% set filtered_lights = filtered_lights + [entity_state.entity_id] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ filtered_lights }}
        all_cover_states: "{{ states.cover }}"
        # Filter out group cover entities the same way
        cover_entities: >-
          {% set filtered_covers = [] %}
          {% for entity_state in all_cover_states %}
            {% if entity_state.attributes is defined %}
              {% set entity_id_attr = entity_state.attributes.entity_id %}
              {% if entity_id_attr is none or entity_id_attr is not iterable or entity_id_attr is string %}
                {% set filtered_covers = filtered_covers + [entity_state.entity_id] %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ filtered_covers }}
        scene_data: {}
    
    # Process all lights
    - repeat:
        for_each: "{{ light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'on') else 0 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Process all covers/shades
    - repeat:
        for_each: "{{ cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'open') else
                                0 if is_state(repeat.item, 'closed') else
                                75 if is_state(repeat.item, 'opening') else
                                25 if is_state(repeat.item, 'closing') else
                                50 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Store the scene data using MQTT
    - variables:
        mqtt_topic: "homeassistant/scenes/{{ scene_name | replace(' ', '_') | lower }}"
        # Create a simple string format: entity_id=value|entity_id=value|...
        simple_data: >-
          {% for entity_id, state in scene_data.items() %}{{ entity_id }}={{ state }}{% if not loop.last %}|{% endif %}{% endfor %}
    
    # Log the data we're storing
    - service: system_log.write
      data:
        message: >
          SAVE SCENE - MQTT:
          Scene name: {{ scene_name }}
          MQTT topic: {{ mqtt_topic }}
          Data length: {{ scene_data | length }} entities
          String length: {{ simple_data | length }} characters
          First 200 chars: {{ simple_data[:200] }}
        level: info
    
    # Publish scene data to MQTT with retain flag
    - service: mqtt.publish
      data:
        topic: "{{ mqtt_topic }}"
        payload: "{{ simple_data }}"
        retain: true
    
    # Wait a moment for MQTT to process
    - delay:
        seconds: 2
    
    # Verify the scene was saved by checking the corresponding sensor entity
    - variables:
        sensor_entity: "sensor.scene_{{ scene_name | replace(' ', '_') | lower }}"
        saved_data: "{{ state_attr(sensor_entity, 'data') }}"
        save_successful: "{{ saved_data != none and saved_data is defined and saved_data | length > 0 }}"
    
    # Log the verification result
    - service: system_log.write
      data:
        message: >
          SAVE SCENE VERIFICATION:
          Scene name: {{ scene_name }}
          Sensor entity: {{ sensor_entity }}
          Save successful: {{ save_successful }}
          Saved data length: {{ saved_data | length if saved_data is defined and saved_data != none else 0 }} characters
          Original data length: {{ simple_data | length }} characters
          Data matches: {{ saved_data == simple_data if save_successful else false }}
        level: info
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          SAVE SCENE:
          Scene name: {{ scene_name }}
          Scene data length: {{ scene_data | length }} entities
          Light entities: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
        level: info
    
    # Notify user with verification status
    - service: notify.notify
      data:
        title: "Scene {{ 'Saved Successfully' if save_successful else 'Save Failed' }}"
        message: >
          Scene '{{ scene_name }}' {{ 'has been saved with ' + (scene_data | length | string) + ' entities and verified in MQTT' if save_successful else 'failed to save to MQTT - check logs for details' }}

load_scene:
  alias: "Load Saved Scene"
  description: "Loads a previously saved scene and applies it to all lights and shades"
  icon: mdi:palette
  mode: single
  fields:
    scene_name:
      name: Scene Name
      description: Name of the scene to load
      required: true
      selector:
        text:
  sequence:
    # Get the scene data from MQTT sensor entity
    - variables:
        mqtt_sensor_entity: "sensor.scene_{{ scene_name | replace(' ', '_') | lower }}"
        json_data: "{{ state_attr(mqtt_sensor_entity, 'data') }}"
        simple_data: "{{ json_data.data if json_data is mapping and 'data' in json_data else json_data }}"
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          LOAD SCENE:
          Scene name: {{ scene_name }}
          MQTT sensor entity: {{ mqtt_sensor_entity }}
          Scene data exists: {{ state_attr(mqtt_sensor_entity, 'data') != none }}
          Scene data length: {{ simple_data | length if simple_data is defined and simple_data != none else 0 }} characters
          First 200 chars: {{ simple_data[:200] if simple_data is defined and simple_data != none else 'undefined' }}
        level: info
    
    # Parse the simple data format into a dictionary
    - variables:
        # Initialize an empty dictionary
        scene_data: {}
        # Split the string by '|' to get entity_id=value pairs
        entity_pairs: "{{ simple_data.split('|') if simple_data is defined and simple_data != none and simple_data != '' else [] }}"
    
    # Process each entity pair and add to scene_data
    - repeat:
        for_each: "{{ entity_pairs }}"
        sequence:
          - variables:
              # Split the pair by '=' to get entity_id and value
              pair_parts: "{{ repeat.item.split('=') }}"
              # Only process if we have both entity_id and value
              has_both_parts: "{{ pair_parts | length == 2 }}"
          
          # Only add to scene_data if we have valid parts
          - condition: template
            value_template: "{{ has_both_parts }}"
          - variables:
              entity_id: "{{ pair_parts[0] }}"
              entity_state: "{{ pair_parts[1] | int }}"
              # Add to scene_data dictionary
              scene_data: "{{ dict(scene_data, **{entity_id: entity_state}) }}"
    
    # Log parsing result
    - service: system_log.write
      data:
        message: >
          PARSE SCENE DATA:
          Pairs found: {{ entity_pairs | length }}
          Scene data parsed successfully: {{ scene_data is mapping }}
          Scene data keys: {{ scene_data.keys() | list | count if scene_data is mapping else 0 }}
        level: info
    
    # Process only lights that are in the scene data, filtering out group entities
    - variables:
        light_entities_in_scene: "{{ scene_data.keys() | select('match', '^light\\.') | list }}"
        # Filter out group entities by checking if they have an 'entity_id' attribute that contains a list
        filtered_light_entities: >-
          {% set filtered_lights = [] %}
          {% for entity_id in light_entities_in_scene %}
            {% set entity_id_attr = state_attr(entity_id, 'entity_id') %}
            {% if entity_id_attr is none or (entity_id_attr is not iterable) or (entity_id_attr is string) %}
              {% set filtered_lights = filtered_lights + [entity_id] %}
            {% endif %}
          {% endfor %}
          {{ filtered_lights }}
    
    - repeat:
        for_each: "{{ filtered_light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Apply the light state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int > 0 }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      brightness_pct: "{{ entity_state }}"
                  - service: system_log.write
                    data:
                      message: "Turning ON {{ entity_id }} with brightness {{ entity_state }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int == 0 }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Turning OFF {{ entity_id }}"
                      level: info
    
    # Process only covers that are in the scene data, filtering out group entities
    - variables:
        cover_entities_in_scene: "{{ scene_data.keys() | select('match', '^cover\\.') | list }}"
        # Filter out group entities by checking if they have an 'entity_id' attribute that contains a list
        filtered_cover_entities: >-
          {% set filtered_covers = [] %}
          {% for entity_id in cover_entities_in_scene %}
            {% set entity_id_attr = state_attr(entity_id, 'entity_id') %}
            {% if entity_id_attr is none or (entity_id_attr is not iterable) or (entity_id_attr is string) %}
              {% set filtered_covers = filtered_covers + [entity_id] %}
            {% endif %}
          {% endfor %}
          {{ filtered_covers }}
    
    - repeat:
        for_each: "{{ filtered_cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Apply the cover state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int >= 50 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Opening cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int < 50 }}"
                sequence:
                  - service: cover.close_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Closing cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
    
    # Notify user
    - service: notify.notify
      data:
        title: "Scene Loaded"
        message: "Scene '{{ scene_name }}' has been loaded"
