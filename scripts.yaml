change_timezone:
  alias: Change System Timezone
  description: "Change Home Assistant timezone via configuration file"
  fields:
    timezone:
      description: "New timezone to set"
      example: "America/New_York"
      selector:
        select:
          options:
            - "America/New_York"
            - "America/Chicago"
            - "America/Denver"
            - "America/Los_Angeles"
            - "America/Anchorage"
            - "Pacific/Honolulu"
            - "America/Phoenix"
            - "America/Indiana/Indianapolis"
            - "America/Detroit"
            - "America/Kentucky/Louisville"
            - "America/Boise"
            - "America/Regina"
            - "America/Winnipeg"
            - "America/Toronto"
            - "America/Vancouver"
            - "America/Edmonton"
            - "America/Calgary"
            - "America/Montreal"
            - "America/Halifax"
            - "America/St_Johns"
  sequence:
    - service: shell_command.change_timezone
      data:
        timezone: "{{ timezone }}"
    - delay:
        seconds: 2
    - service: persistent_notification.create
      data:
        title: "Timezone Changed"
        message: "System timezone has been changed to {{ timezone }}. Home Assistant will restart in 10 seconds to apply changes."
    - service: script.notify_home
      data:
        title: "Timezone Changed"
        message: "System timezone changed to {{ timezone }}. Restarting Home Assistant..."
    - delay:
        seconds: 10
    - service: homeassistant.restart
  mode: single
  icon: mdi:clock-time-four

auto_detect_timezone:
  alias: Auto-Detect Timezone from Location
  description: "Automatically detect and set timezone based on current GPS location"
  sequence:
    - condition: template
      value_template: >
        {{ states('sensor.gps_127_0_0_1_latitude') not in ['unknown', 'unavailable', 'none'] and
           states('sensor.gps_127_0_0_1_longitude') not in ['unknown', 'unavailable', 'none'] }}
    - service: persistent_notification.create
      data:
        title: "Detecting Timezone"
        message: "Detecting timezone for current location..."
    - delay:
        seconds: 3
    - service: homeassistant.update_entity
      target:
        entity_id: sensor.location_timezone
    - delay:
        seconds: 2
    - condition: template
      value_template: >
        {{ states('sensor.location_timezone') not in ['unknown', 'unavailable', 'none'] and
           states('sensor.location_timezone') != states('input_select.timezone') }}
    - service: input_select.select_option
      target:
        entity_id: input_select.timezone
      data:
        option: "{{ states('sensor.location_timezone') }}"
    - service: persistent_notification.create
      data:
        title: "Timezone Auto-Detected"
        message: "Detected timezone: {{ states('sensor.location_timezone') }}. Setting system timezone..."
    - service: script.notify_home
      data:
        title: "Timezone Auto-Detected"
        message: "Detected timezone: {{ states('sensor.location_timezone') }}"
  mode: single
  icon: mdi:map-marker-clock

store_bus:
  alias: Store Bus
  sequence:
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_pump
      - switch.heat
      - switch.air_conditioning
  - service: notify.notify
    data:
      message: Foretravel has been stored
      title: Foretravel Stored
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_autofill
      - switch.water_pump
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
  - delay:
      hours: 0
      minutes: 2
      seconds: 0
      milliseconds: 0
  - service: lock.lock
    data: {}
    target:
      entity_id: lock.locks
  - service: cover.close_cover
    data: {}
    target:
      entity_id: cover.all_night_shades
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Bus is being stored.
  - service: input_boolean.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: input_boolean.storage
  mode: single
good_night:
  alias: Good Night
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id: light.all_ceiling_lights
    service: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id: light.exterior_lights
    service: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
    service: light.turn_off
  - data: {}
    target:
      entity_id: lock.locks
    service: lock.lock
  - data: {}
    target:
      entity_id: cover.all_night_shades
    service: cover.close_cover
  - data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
    service: homeassistant.turn_on
  mode: single
good_morning:
  alias: Good Morning
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.dimmer_3_19
      - light.cockpit_accents
      - light.living_room_accents
      - light.rear_bath_accent
      - light.dimmer_3_10
      - light.entry_light_2
    service: light.turn_on
  - delay:
      hours: 0
      minutes: 5
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - cover.windshield_night
      - cover.d_s_living_room_night
      - cover.dinette_night
    service: cover.open_cover
  mode: single
evening:
  alias: Evening
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.exterior_accents
      - light.interior_accents
      - light.porch_handle
      - light.awning_lights
    service: light.turn_on
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data: {}
    target:
      entity_id: cover.all_day_shades
    service: cover.close_cover
  mode: single
  icon: mdi:clock-time-seven
tv_time:
  alias: TV Time
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - service: light.turn_on
    data: {}
    target:
      entity_id:
      - light.interior_accents
    enabled: false
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.cockpit_accents
      - light.living_room_accents
  - service: cover.close_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.living_night_shades
  mode: single
  icon: mdi:television

drive_time:
  alias: Drive Time
  sequence:
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.cockpit_day_shades
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.exterior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 1
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.interior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_lights
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.water_autofill
      - switch.water_pump
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - media_player.tv_samsung_6_series_50
      - media_player.samsung_6_series_50
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - light.dimmer_3_14
      - light.entry_light_2
  - service: timer.start
    data: {}
    target:
      entity_id: timer.setlocationtimer
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Drive time!
  - service: input_boolean.turn_off
    metadata: {}
    data: {}
    target:
      entity_id:
      - input_boolean.storage
      - input_boolean.camping
  - service: switch.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: switch.ac_4
  mode: single
  icon: mdi:steering
all_bright:
  alias: All Bright
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 1
      seconds: 0
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id: light.all_lights
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.all_day_shades
      - cover.all_night_shades
  mode: single
  icon: mdi:weather-sunny
set_current_location_as_home:
  alias: Set Current location as home
  sequence:
  - condition: state
    entity_id: sensor.gps_127_0_0_1_latitude
    state: '{% if sensor.latitude | is_number %}'
    enabled: false
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    enabled: false
    service: homeassistant.set_location
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    service: homeassistant.set_location
  mode: single
notify_iphone:
  alias: Notify iPhone
  sequence:

  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    service: notify.mobile_app_iphone_15_pro_max
  mode: single
  fields:
    title:
      selector:
        text:
      name: Title
      default: Foretravel
    message:
      selector:
        text:
      name: Message
tts_alert:
  alias: TTS alert
  sequence:
  - service: media_player.play_media
    target:
      entity_id:
      - media_player.kitchen
      - media_player.bedroom_2
    data:
      media_content_id: media-source://media_source/local/f1-radio-notification.mp3
      media_content_type: audio/mpeg
    metadata:
      title: f1-radio-notification.mp3
      thumbnail:
      media_class: music
      children_media_class:
      navigateIds:
      - {}
      - media_content_type: app
        media_content_id: media-source://media_source
  - service: tts.speak
    data:
      cache: true
      message: '{{message}}'
      media_player_entity_id: media_player.kitchen,media_player.bedroom_2
    target:
      entity_id: tts.piper
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
notify_home:
  alias: Notify Home
  sequence:
  - data:
      message: '{{message}}'
      title: '{{title}}'
    service: script.notify_iphone
  - data:
      message: '{{message}}'
      title: '{{title}}'
    service: script.tts_alert
  - data:
      title: '{{title}}'
      message: '{{message}}'
    service: notify.persistent_notification
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
      required: true
    title:
      selector:
        text:
      name: Title
      default: Foretravel
ai_analyze_dash_video:
  alias: AI - Analyze Dash Video
  sequence:
  - data:
      filename: /config/www/snapshot_dash.jpg
    service: camera.snapshot
    target:
      device_id: eea91240afc6576d615f0b18aa1ec28e
  - service: llmvision.stream_analyzer
    data:
      remember: false
      duration: 5
      max_frames: 3
      include_filename: false
      target_width: 1280
      detail: low
      max_tokens: 100
      temperature: 0.2
      expose_images: false
      provider: 01JDN5XHDWG1Q8TJ5718TYR6EE
      message: Analyze and describe the image. Highlight any people or vehicles. Keep
        the resonse to 128 characters.
      image_entity:
      - camera.g5_flex_high_resolution_channel
    response_variable: response
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data:
      message: 'Response received: {{ response.response_text }}'
    service: system_log.write
  - condition: template
    value_template: '{{ response.response_text is not none and response.response_text
      | length > 0 }}'
  - data:
      value: '{{ response.response_text }}'
    target:
      entity_id: input_text.llmvision_response
    service: input_text.set_value
  - service: notify.mobile_app_iphone_15_pro_max
    metadata: {}
    data:
      title: Foretravel - Dash
      message: '{{ response.response_text }}'
      data:
        image: http://192.168.100.175:8123/local/snapshot_dash.jpg
        content-type: image/jpeg
        hide-thumbnail: false
  description: Analyzes the dash video and updates input_text with the response.
  icon: mdi:cube-scan


lock_all_cargo_doors:
  alias: "Lock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.lock
              target:
                entity_id: lock.cargo_door_lock_all
      default:

        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_0
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_4

unlock_all_cargo_doors:
  alias: "Unlock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.unlock
              target:
                entity_id: lock.cargo_door_lock_all
      default:
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_0
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.unlock  
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_4

# Generator Shutdown with Verification Script
generator_shutdown_with_verification:
  alias: "Generator Shutdown with Verification"
  description: "Turn off generator after specified minutes, verify shutdown, retry if needed, and notify on failure"
  fields:
    delay_minutes:
      description: "Number of minutes to wait before shutting down generator"
      example: 30
      required: false
      default: 0
      selector:
        number:
          min: 0
          max: 480
          step: 1
          unit_of_measurement: "minutes"
    notification_service:
      description: "Notification service to use for alerts"
      example: "notify.mobile_app"
      required: false
      default: "notify.mobile_app"
      selector:
        text:
  sequence:
    - choose:
        - conditions:
            - condition: state
              entity_id: switch.generator
              state: 'off'
          sequence:
            - stop: "Generator already off"

    # Wait for the specified delay
    - delay:
        minutes: "{{ delay_minutes | int }}"

    # Turn off generator
    - service: switch.turn_off
      target:
        entity_id: switch.generator
      
    # Wait 30 seconds for generator to shut down
    - delay:
        seconds: 30
    
    # Check if generator is off, retry up to 3 times
    - repeat:
        count: 3
        sequence:
          # Check if generator is still running
          - condition: template
            value_template: "{{ is_state('switch.generator', 'on') }}"
          # If still running, turn off again
          - service: switch.turn_off
            target:
              entity_id: switch.generator
            
          # Wait 30 seconds before next check
          - delay:
              seconds: 30
    
    # Final verification - if still running, send notification
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ is_state('switch.generator', 'on') }}"
          sequence:
            - service: "{{ notification_service }}"
              data:
                title: "Generator Shutdown Failed"
                message: "Unable to stop generator after {{ delay_minutes }} minutes and 3 retry attempts. Manual intervention required."
                data:
                  priority: "high"
                  channel: "alerts"

# Generator Start with Verification Script
generator_start_with_verification:
  alias: "Generator Start with Verification"
  description: "Turn on generator after specified minutes, verify startup, retry if needed, and notify on failure"
  fields:
    delay_minutes:
      description: "Number of minutes to wait before starting generator"
      example: 5
      required: false
      default: 0
      selector:
        number:
          min: 0
          max: 480
          step: 1
          unit_of_measurement: "minutes"
    notification_service:
      description: "Notification service to use for alerts"
      example: "notify.mobile_app"
      required: false
      default: "notify.mobile_app"
      selector:
        text:
  sequence:
    - choose:
        - conditions:
            - condition: state
              entity_id: switch.generator
              state: 'on'
          sequence:
            - stop: "Generator already running"

    # Wait for the specified delay
    - delay:
        minutes: "{{ delay_minutes | int }}"

    # Turn on generator
    - service: switch.turn_on
      target:
        entity_id: switch.generator
    
    # Wait 30 seconds for generator to start
    - delay:
        seconds: 30
    
    # Check if generator is on, retry up to 3 times
    - repeat:
        count: 3
        sequence:
          # Check if generator is still off
          - condition: template
            value_template: "{{ is_state('switch.generator', 'off') }}"
          # If still off, turn on again
          - service: switch.turn_on
            target:
              entity_id: switch.generator
          # Wait 60 seconds before next check
          - delay:
              seconds: 60

    # Final verification - if still off, send notification
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ is_state('switch.generator', 'off') }}"
          sequence:
            - service: "{{ notification_service }}"
              data:
                title: "Generator Startup Failed"
                message: "Unable to start generator after {{ delay_minutes }} minutes and 3 retry attempts. Manual intervention required."
                data:
                  priority: "high"
                  channel: "alerts"

start_generator:
  alias: "Start Generator"
  sequence:
    - service: script.generator_start_with_verification
      data:
        delay_minutes: 0

stop_generator:
  alias: "Stop Generator"
  sequence:
    - service: script.generator_shutdown_with_verification
      data:
        delay_minutes: 0

generator_start_reliable:
  alias: "Generator Start - Retry"
  description: "Attempts to start the generator up to three times with notifications between retries"
  mode: single
  sequence:
    # First attempt
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Attempting to start the generator (try 1 of 3)."
    - service: switch.turn_on
      target:
        entity_id: switch.generator
    - delay:
        seconds: 20
    - choose:
        - conditions:
            - condition: state
              entity_id: switch.generator
              state: 'on'
          sequence:
            - service: script.notify_home
              data:
                title: "Generator Start"
                message: "Generator started successfully on the first attempt."
            - stop: "Generator started successfully"

    # Wait before second attempt
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Generator still off. Waiting 30 seconds before retrying (try 2 of 3)."
    - delay:
        seconds: 30

    # Second attempt
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Attempting to start the generator (try 2 of 3)."
    - service: switch.turn_on
      target:
        entity_id: switch.generator
    - delay:
        seconds: 20
    - choose:
        - conditions:
            - condition: state
              entity_id: switch.generator
              state: 'on'
          sequence:
            - service: script.notify_home
              data:
                title: "Generator Start"
                message: "Generator started successfully on the second attempt."
            - stop: "Generator started after second attempt"

    # Wait before third attempt
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Generator still off. Waiting 1 minute before the final attempt (try 3 of 3)."
    - delay:
        minutes: 1

    # Third attempt
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Attempting to start the generator (try 3 of 3)."
    - service: switch.turn_on
      target:
        entity_id: switch.generator
    - delay:
        seconds: 20
    - choose:
        - conditions:
            - condition: state
              entity_id: switch.generator
              state: 'on'
          sequence:
            - service: script.notify_home
              data:
                title: "Generator Start"
                message: "Generator started successfully on the final attempt."
            - stop: "Generator started after final attempt"

    # All attempts failed
    - service: script.notify_home
      data:
        title: "Generator Start"
        message: "Generator failed to start after three attempts. Manual intervention required."

save_scene:
  alias: "Save Current Scene"
  description: "Saves the current lights and shades state into a numbered scene slot"
  fields:
    slot_number:
      name: Scene Slot
      description: Scene slot number to save (1-12)
      required: true
      selector:
        number:
          min: 1
          max: 12
          step: 1
    scene_name:
      name: Scene Name
      description: Friendly label stored with the scene (optional)
      selector:
        text:
  sequence:
    - variables:
        slot: "{{ slot_number | int }}"
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ not (1 <= slot <= 12) }}"
          sequence:
            - service: system_log.write
              data:
                message: >-
                  SAVE SCENE - Invalid slot {{ slot_number }} requested. Valid range is 1-12.
                level: warning
            - service: notify.notify
              data:
                title: "Scene Save Failed"
                message: "Scene slot {{ slot_number }} is invalid. Choose a value between 1 and 12."
            - stop: "Invalid scene slot"
    - variables:
        helper_name_entity: "{{ 'input_text.scene_slot_' ~ slot ~ '_name' }}"
        friendly_name: >-
          {% set provided = scene_name | default('') | trim %}
          {% set existing = states(helper_name_entity) | default('') | trim %}
          {% if provided != '' %}
            {{ provided }}
          {% elif existing != '' %}
            {{ existing }}
          {% else %}
            Scene Slot {{ slot }}
          {% endif %}
        mqtt_topic: "{{ 'homeassistant/scenes/scene_' ~ slot }}"
        sensor_entity: "{{ 'sensor.scene_slot_' ~ slot }}"
        slot_label: "{{ 'Scene Slot ' ~ slot }}"
    - service: input_text.set_value
      target:
        entity_id: "{{ helper_name_entity }}"
      data:
        value: "{{ friendly_name }}"
    # Filter light entities - exclude groups (entities with entity_id attribute)
    - variables:
        all_light_entities: >-
          {{ states.light | map(attribute='entity_id') | list }}
        light_groups: >-
          {{ states.light
             | selectattr('attributes.entity_id', 'defined')
             | map(attribute='entity_id') 
             | list }}
        light_entities: >-
          {% set groups = light_groups %}
          {{ states.light
             | map(attribute='entity_id')
             | reject('in', groups)
             | list }}
    
    # Log light filtering results
    - service: system_log.write
      data:
        message: >
          SAVE SCENE DEBUG - Light Filtering:
          Total light entities: {{ all_light_entities | length }}
          Light groups (excluded): {{ light_groups | length }}
          Real lights (included): {{ light_entities | length }}
          
          All lights: {{ all_light_entities }}
          Light groups: {{ light_groups }}
          Real lights: {{ light_entities }}
        level: info
    
    # Filter cover entities - exclude groups (entities with entity_id attribute)
    - variables:
        all_cover_entities: >-
          {% set all_covers = states.cover | map(attribute='entity_id') | list %}
          {{ all_covers }}
        # Filter out any cover that contains 'shades' or looks like a group
        cover_entities: >-
          {{ states.cover 
             | rejectattr('entity_id', 'search', 'shades')
             | rejectattr('entity_id', 'search', 'all_')
             | rejectattr('attributes.entity_id', 'defined')
             | rejectattr('attributes.position_template', 'defined')
             | map(attribute='entity_id') 
             | list }}
        scene_data: {}
    
    # Log cover filtering results
    - service: system_log.write
      data:
        message: >
          SAVE SCENE DEBUG - Cover Filtering:
          Total cover entities: {{ all_cover_entities | length }}
          Real covers (included): {{ cover_entities | length }}
          
          All covers: {{ all_cover_entities }}
          Real covers (no groups): {{ cover_entities }}
        level: info
    
    # Process all lights
    - repeat:
        for_each: "{{ light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'on') else 0 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Process all covers/shades
    - repeat:
        for_each: "{{ cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'open') else
                                0 if is_state(repeat.item, 'closed') else
                                75 if is_state(repeat.item, 'opening') else
                                25 if is_state(repeat.item, 'closing') else
                                50 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Store the scene data using MQTT
    - variables:
        # Create a simple string format: entity_id=value|entity_id=value|...
        simple_data: >-
          {% for entity_id, state in scene_data.items() %}{{ entity_id }}={{ state }}{% if not loop.last %}|{% endif %}{% endfor %}
    
    # Log the data we're storing with detailed breakdown
    - service: system_log.write
      data:
        message: >
          SAVE SCENE - MQTT DATA:
          {{ slot_label }} friendly name: {{ friendly_name }}
          MQTT topic: {{ mqtt_topic }}
          Total entities in scene_data: {{ scene_data | length }}
          Light entities in scene_data: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities in scene_data: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
          
          Light entities saved: {{ scene_data.keys() | select('match', '^light\\.') | list }}
          Cover entities saved: {{ scene_data.keys() | select('match', '^cover\\.') | list }}
          
          String length: {{ simple_data | length }} characters
          First 500 chars: {{ simple_data[:500] }}
        level: info
    
    # Publish scene data to MQTT with retain flag
    - service: mqtt.publish
      data:
        topic: "{{ mqtt_topic }}"
        payload: "{{ simple_data }}"
        retain: true
    
    # Wait a moment for MQTT to process
    - delay:
        seconds: 2
    
    # Verify the scene was saved by checking the corresponding sensor entity
    - variables:
        saved_data: "{{ state_attr(sensor_entity, 'data') }}"
        save_successful: "{{ saved_data != none and saved_data is defined and saved_data | length > 0 }}"
    
    # Log the verification result
    - service: system_log.write
      data:
        message: >
          SAVE SCENE VERIFICATION:
          {{ slot_label }} friendly name: {{ friendly_name }}
          Sensor entity: {{ sensor_entity }}
          Save successful: {{ save_successful }}
          Saved data length: {{ saved_data | length if saved_data is defined and saved_data != none else 0 }} characters
          Original data length: {{ simple_data | length }} characters
          Data matches: {{ saved_data == simple_data if save_successful else false }}
        level: info
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          SAVE SCENE:
          {{ slot_label }} friendly name: {{ friendly_name }}
          Scene data length: {{ scene_data | length }} entities
          Light entities: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
        level: info
    
    # Notify user with verification status
    - service: notify.notify
      data:
        title: "Scene {{ 'Saved Successfully' if save_successful else 'Save Failed' }}"
        message: >
          {{ slot_label }} ({{ friendly_name }}) {{ 'has been saved with ' + (scene_data | length | string) + ' entities and verified in MQTT' if save_successful else 'failed to save to MQTT - check logs for details' }}

load_scene:
  alias: "Load Saved Scene"
  description: "Loads a saved scene slot and applies it to all lights and shades"
  icon: mdi:palette
  mode: single
  fields:
    slot_number:
      name: Scene Slot
      description: Scene slot number to load (1-12)
      required: true
      selector:
        number:
          min: 1
          max: 12
          step: 1
  sequence:
    - variables:
        slot: "{{ slot_number | int }}"
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ not (1 <= slot <= 12) }}"
          sequence:
            - service: system_log.write
              data:
                message: >-
                  LOAD SCENE - Invalid slot {{ slot_number }} requested. Valid range is 1-12.
                level: warning
            - service: notify.notify
              data:
                title: "Scene Load Failed"
                message: "Scene slot {{ slot_number }} is invalid. Choose a value between 1 and 12."
            - stop: "Invalid scene slot"
    - variables:
        helper_name_entity: "{{ 'input_text.scene_slot_' ~ slot ~ '_name' }}"
        friendly_name: >-
          {% set current = states('input_text.scene_slot_' ~ slot ~ '_name') | default('') | trim %}
          {% if current != '' %}
            {{ current }}
          {% else %}
            Scene Slot {{ slot }}
          {% endif %}
        sensor_entity: "{{ 'sensor.scene_slot_' ~ slot }}"
        camping_entity: "input_boolean.camping"
        slot_label: "{{ 'Scene Slot ' ~ slot }}"
    # Log scene load attempt
    - service: system_log.write
      data:
        message: "Loading {{ slot_label }} ({{ friendly_name }})"
        level: info

    - choose:
        - conditions:
            - condition: template
              value_template: "{{ is_state(camping_entity, 'off') }}"
          sequence:
            - service: system_log.write
              data:
                message: "{{ slot_label }} loaded while camping mode is off."
                level: warning
            - service: notify.notify
              data:
                title: "Scene Loaded (Camping Off)"
                message: "{{ slot_label }} ({{ friendly_name }}) ran while camping mode is off."

    - variables:
        scene_data_raw: "{{ state_attr(sensor_entity, 'data') }}"
        scene_data_simple: "{{ scene_data_raw.data if scene_data_raw is mapping and 'data' in scene_data_raw else scene_data_raw }}"
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          LOAD SCENE:
          {{ slot_label }} friendly name: {{ friendly_name }}
          MQTT sensor entity: {{ sensor_entity }}
          Scene data exists: {{ scene_data_raw != none }}
          Scene data length: {{ (scene_data_simple | string | length) if scene_data_simple not in [none, '', 'None', 'unknown', 'unavailable'] else 0 }} characters
          First 200 chars: {{ (scene_data_simple | string)[:200] if scene_data_simple not in [none, '', 'None', 'unknown', 'unavailable'] else 'undefined' }}
        level: info

    - choose:
        - conditions:
            - condition: template
              value_template: "{{ scene_data_simple not in [none, '', 'None', 'unknown', 'unavailable'] }}"
          sequence: []
      default:
        - service: notify.notify
          data:
            title: "Scene Load Failed"
            message: "{{ slot_label }} ({{ friendly_name }}) does not have stored data yet."
        - stop: "Scene slot empty"
    
    # Parse the simple data format into a dictionary
    - variables:
        # Initialize an empty dictionary
        scene_data: {}
        # Split the string by '|' to get entity_id=value pairs
        entity_pairs: "{{ (scene_data_simple | string).split('|') if scene_data_simple not in [none, '', 'None', 'unknown', 'unavailable'] else [] }}"
    
    # Process each entity pair and add to scene_data
    - repeat:
        for_each: "{{ entity_pairs }}"
        sequence:
          - variables:
              # Split the pair by '=' to get entity_id and value
              pair_parts: "{{ repeat.item.split('=') }}"
              # Only process if we have both entity_id and value
              has_both_parts: "{{ pair_parts | length == 2 }}"
          
          # Only add to scene_data if we have valid parts
          - condition: template
            value_template: "{{ has_both_parts }}"
          - variables:
              entity_id: "{{ pair_parts[0] }}"
              entity_state: "{{ pair_parts[1] | int }}"
              # Add to scene_data dictionary
              scene_data: "{{ dict(scene_data, **{entity_id: entity_state}) }}"
    
    # Log parsing result
    - service: system_log.write
      data:
        message: >
          PARSE SCENE DATA:
          {{ slot_label }} friendly name: {{ friendly_name }}
          Pairs found: {{ entity_pairs | length }}
          Scene data parsed successfully: {{ scene_data is mapping }}
          Scene data keys: {{ scene_data.keys() | list | count if scene_data is mapping else 0 }}
        level: info
    
    # Process only lights that are in the scene data
    - variables:
        light_entities_in_scene: "{{ scene_data.keys() | select('match', '^light\\.') | list }}"
        filtered_light_entities: "{{ light_entities_in_scene }}"
    
    - repeat:
        for_each: "{{ filtered_light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Apply the light state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int > 0 }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      brightness_pct: "{{ entity_state }}"
                  - service: system_log.write
                    data:
                      message: "Turning ON {{ entity_id }} with brightness {{ entity_state }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int == 0 }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Turning OFF {{ entity_id }}"
                      level: info
    
    # Process only covers that are in the scene data
    - variables:
        cover_entities_in_scene: "{{ scene_data.keys() | select('match', '^cover\\.') | list }}"
        # Filter out any entity containing 'shades' or 'all_' - these are groups
        filtered_cover_entities: >-
          {{ cover_entities_in_scene 
             | reject('search', 'shades')
             | reject('search', 'all_')
             | list }}
    
    # Log filtering results
    - service: system_log.write
      data:
        message: >
          LOAD SCENE - Cover Filtering:
          Total covers in scene: {{ cover_entities_in_scene | length }}
          Individual shades to control: {{ filtered_cover_entities | length }}
          Excluded groups: {{ cover_entities_in_scene | select('search', 'shades') | list + cover_entities_in_scene | select('search', 'all_') | list }}
        level: info
    
    - repeat:
        for_each: "{{ filtered_cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Apply the cover state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int >= 50 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Opening cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
                  # Small delay to prevent overlapping commands
                  - delay:
                      milliseconds: 100
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int < 50 }}"
                sequence:
                  - service: cover.close_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Closing cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
                  # Small delay to prevent overlapping commands
                  - delay:
                      milliseconds: 100
    
    # Notify user
    - service: notify.notify
      data:
        title: "Scene Loaded"
        message: "{{ slot_label }} ({{ friendly_name }}) has been loaded"

clear_scene_slot:
  alias: "Clear Stored Scene"
  description: "Clears stored scene data, name, and schedule for a slot"
  icon: mdi:content-save-off-outline
  mode: single
  fields:
    slot_number:
      name: Scene Slot
      description: Scene slot number to clear (1-12)
      required: true
      selector:
        number:
          min: 1
          max: 12
          step: 1
  sequence:
    - variables:
        slot: "{{ slot_number | int }}"
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ not (1 <= slot <= 12) }}"
          sequence:
            - service: system_log.write
              data:
                message: >-
                  CLEAR SCENE - Invalid slot {{ slot_number }} requested. Valid range is 1-12.
                level: warning
            - service: notify.notify
              data:
                title: "Scene Clear Failed"
                message: "Scene slot {{ slot_number }} is invalid. Choose a value between 1 and 12."
            - stop: "Invalid scene slot"
    - variables:
        helper_name_entity: "{{ 'input_text.scene_slot_' ~ slot ~ '_name' }}"
        schedule_enabled_entity: "{{ 'input_boolean.scene_slot_' ~ slot ~ '_schedule_enabled' }}"
        schedule_type_entity: "{{ 'input_select.scene_slot_' ~ slot ~ '_schedule_type' }}"
        schedule_time_entity: "{{ 'input_datetime.scene_slot_' ~ slot ~ '_time' }}"
        schedule_offset_entity: "{{ 'input_number.scene_slot_' ~ slot ~ '_offset_minutes' }}"
        mqtt_topic: "{{ 'homeassistant/scenes/scene_' ~ slot }}"
        slot_label: "{{ 'Scene Slot ' ~ slot }}"
    - service: system_log.write
      data:
        message: "Clearing {{ slot_label }}"
        level: info
    - service: mqtt.publish
      data:
        topic: "{{ mqtt_topic }}"
        payload: "{}"
        retain: true
    - service: input_text.set_value
      target:
        entity_id: "{{ helper_name_entity }}"
      data:
        value: ""
    - service: input_boolean.turn_off
      target:
        entity_id: "{{ schedule_enabled_entity }}"
    - service: input_select.select_option
      target:
        entity_id: "{{ schedule_type_entity }}"
      data:
        option: "time"
    - service: input_number.set_value
      target:
        entity_id: "{{ schedule_offset_entity }}"
      data:
        value: 0
    - service: input_datetime.set_datetime
      target:
        entity_id: "{{ schedule_time_entity }}"
      data:
        time: "21:00:00"
    - service: notify.notify
      data:
        title: "Scene Cleared"
        message: "{{ slot_label }} has been cleared."

# Master Thermostat Control Scripts
master_thermostat_set_cool:
  alias: "Master Thermostat - Set Cool Temperature"
  description: "Set all thermostats to cool mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 72
      selector:
        number:
          min: 60
          max: 90
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: cool

master_thermostat_set_heat:
  alias: "Master Thermostat - Set Heat Temperature"
  description: "Set all thermostats to heat mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 68
      selector:
        number:
          min: 50
          max: 85
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: heat

master_thermostat_set_auto:
  alias: "Master Thermostat - Set Auto Mode"
  description: "Set all thermostats to auto mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 70
      selector:
        number:
          min: 60
          max: 85
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: auto

master_thermostat_off:
  alias: "Master Thermostat - Turn Off"
  description: "Turn off all thermostats"
  sequence:
    - service: climate.set_hvac_mode
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        hvac_mode: off

master_thermostat_set_temperature:
  alias: "Master Thermostat - Set Temperature"
  description: "Set temperature for all thermostats based on current mode"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 72
      selector:
        number:
          min: 50
          max: 90
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"

master_thermostat_set_mode:
  alias: "Master Thermostat - Set HVAC Mode"
  description: "Set HVAC mode for all thermostats"
  fields:
    hvac_mode:
      description: "HVAC mode to set"
      example: "cool"
      selector:
        select:
          options:
            - "off"
            - "heat"
            - "cool"
            - "auto"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'off' }}"
          sequence:
            - service: script.master_thermostat_off
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'heat' }}"
          sequence:
            - service: script.master_thermostat_set_heat
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'cool' }}"
          sequence:
            - service: script.master_thermostat_set_cool
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'auto' }}"
          sequence:
            - service: script.master_thermostat_set_auto
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"
