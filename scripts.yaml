store_bus:
  alias: Store Bus
  sequence:
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_pump
      - switch.heat
      - switch.air_conditioning
  - service: notify.notify
    data:
      message: Foretravel has been stored
      title: Foretravel Stored
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_autofill
      - switch.water_pump
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
  - delay:
      hours: 0
      minutes: 2
      seconds: 0
      milliseconds: 0
  - service: lock.lock
    data: {}
    target:
      entity_id: lock.locks
  - service: cover.close_cover
    data: {}
    target:
      entity_id: cover.all_night_shades
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Bus is being stored.
  - service: input_boolean.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: input_boolean.storage
  mode: single
good_night:
  alias: Good Night
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id: light.all_ceiling_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id: light.exterior_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
    action: light.turn_off
  - data: {}
    target:
      entity_id: lock.locks
    action: lock.lock
  - data: {}
    target:
      entity_id: cover.all_night_shades
    action: cover.close_cover
  - data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
    action: homeassistant.turn_on
  mode: single
good_morning:
  alias: Good Morning
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.dimmer_3_19
      - light.cockpit_accents
      - light.living_room_accents
      - light.rear_bath_accent
      - light.dimmer_3_10
      - light.entry_light_2
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 5
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - cover.windshield_night
      - cover.d_s_living_room_night
      - cover.dinette_night
    action: cover.open_cover
  mode: single
evening:
  alias: Evening
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.exterior_accents
      - light.interior_accents
      - light.porch_handle
      - light.awning_lights
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data: {}
    target:
      entity_id: cover.all_day_shades
    action: cover.close_cover
  mode: single
  icon: mdi:clock-time-seven
tv_time:
  alias: TV Time
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - service: light.turn_on
    data: {}
    target:
      entity_id:
      - light.interior_accents
    enabled: false
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.cockpit_accents
      - light.living_room_accents
  - service: cover.close_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.living_night_shades
  mode: single
  icon: mdi:television
drive_time:
  alias: Drive Time
  sequence:
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.cockpit_day_shades
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.exterior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 1
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.interior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_lights
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.water_autofill
      - switch.water_pump
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - media_player.tv_samsung_6_series_50
      - media_player.samsung_6_series_50
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - light.dimmer_3_14
      - light.entry_light_2
  - service: timer.start
    data: {}
    target:
      entity_id: timer.setlocationtimer
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Drive time!
  - service: input_boolean.turn_off
    metadata: {}
    data: {}
    target:
      entity_id:
      - input_boolean.storage
      - input_boolean.camping
  - service: switch.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: switch.ac_4
  mode: single
  icon: mdi:steering
all_bright:
  alias: All Bright
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 1
      seconds: 0
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id: light.all_lights
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.all_day_shades
      - cover.all_night_shades
  mode: single
  icon: mdi:weather-sunny
set_current_location_as_home:
  alias: Set Current location as home
  sequence:
  - condition: state
    entity_id: sensor.gps_127_0_0_1_latitude
    state: '{% if sensor.latitude | is_number %}'
    enabled: false
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    enabled: false
    action: homeassistant.set_location
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    action: homeassistant.set_location
  mode: single
notify_iphone:
  alias: Notify iPhone
  sequence:

  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    action: notify.notify
  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    action: notify.mobile_app_iphone_15_pro_max
  mode: single
  fields:
    title:
      selector:
        text:
      name: Title
      default: Foretravel
    message:
      selector:
        text:
      name: Message
tts_alert:
  alias: TTS alert
  sequence:
  - service: media_player.play_media
    target:
      entity_id:
      - media_player.kitchen
      - media_player.bedroom_2
    data:
      media_content_id: media-source://media_source/local/f1-radio-notification.mp3
      media_content_type: audio/mpeg
    metadata:
      title: f1-radio-notification.mp3
      thumbnail:
      media_class: music
      children_media_class:
      navigateIds:
      - {}
      - media_content_type: app
        media_content_id: media-source://media_source
  - service: tts.speak
    data:
      cache: true
      message: '{{message}}'
      media_player_entity_id: media_player.kitchen,media_player.bedroom_2
    target:
      entity_id: tts.piper
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
notify_home:
  alias: Notify Home
  sequence:
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.notify_iphone
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.tts_alert
  - data:
      title: '{{title}}'
      message: '{{message}}'
    action: notify.persistent_notification
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
      required: true
    title:
      selector:
        text:
      name: Title
      default: Foretravel
ai_analyze_dash_video:
  alias: AI - Analyze Dash Video
  sequence:
  - data:
      filename: /config/www/snapshot_dash.jpg
    action: camera.snapshot
    target:
      device_id: eea91240afc6576d615f0b18aa1ec28e
  - action: llmvision.stream_analyzer
    data:
      remember: false
      duration: 5
      max_frames: 3
      include_filename: false
      target_width: 1280
      detail: low
      max_tokens: 100
      temperature: 0.2
      expose_images: false
      provider: 01JDN5XHDWG1Q8TJ5718TYR6EE
      message: Analyze and describe the image. Highlight any people or vehicles. Keep
        the resonse to 128 characters.
      image_entity:
      - camera.g5_flex_high_resolution_channel
    response_variable: response
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data:
      message: 'Response received: {{ response.response_text }}'
    action: system_log.write
  - condition: template
    value_template: '{{ response.response_text is not none and response.response_text
      | length > 0 }}'
  - data:
      value: '{{ response.response_text }}'
    target:
      entity_id: input_text.llmvision_response
    action: input_text.set_value
  - action: notify.mobile_app_iphone_15_pro_max
    metadata: {}
    data:
      title: Foretravel - Dash
      message: '{{ response.response_text }}'
      data:
        image: http://192.168.100.175:8123/local/snapshot_dash.jpg
        content-type: image/jpeg
        hide-thumbnail: false
  description: Analyzes the dash video and updates input_text with the response.
  icon: mdi:cube-scan


lock_all_cargo_doors:
  alias: "Lock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.lock
              target:
                entity_id: lock.cargo_door_lock_all
      default:

        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_0
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_4

unlock_all_cargo_doors:
  alias: "Unlock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.unlock
              target:
                entity_id: lock.cargo_door_lock_all
      default:
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_0
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.unlock  
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_4

save_scene:
  alias: "Save Current Scene"
  description: "Saves the current state of all lights and shades as a scene with the given name"
  fields:
    scene_name:
      name: Scene Name
      description: Name to save this scene as
      required: true
      selector:
        text:
  sequence:
    # First, collect all light states
    - variables:
        light_entities: >
          {% set all_lights = states.light | map(attribute='entity_id') | list %}
          {{ all_lights }}
        cover_entities: >
          {% set all_covers = states.cover | map(attribute='entity_id') | list %}
          {{ all_covers }}
        scene_data: {}
    
    # Process all lights
    - repeat:
        for_each: "{{ light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: >
                {% if is_state(repeat.item, 'on') %}
                  100
                {% else %}
                  0
                {% endif %}
          - variables:
              scene_data: >
                {% set updated_data = scene_data %}
                {% set updated_data = dict(scene_data, **{repeat.item: entity_state}) %}
                {{ updated_data }}
    
    # Process all covers/shades
    - repeat:
        for_each: "{{ cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: >
                {% if is_state(repeat.item, 'open') %}
                  100
                {% elif is_state(repeat.item, 'closed') %}
                  0
                {% elif is_state(repeat.item, 'opening') %}
                  75
                {% elif is_state(repeat.item, 'closing') %}
                  25
                {% else %}
                  50
                {% endif %}
          - variables:
              scene_data: >
                {% set updated_data = scene_data %}
                {% set updated_data = dict(scene_data, **{repeat.item: entity_state}) %}
                {{ updated_data }}
    
    # Log the scene data before storing
    - service: system_log.write
      data:
        message: >
          SAVE SCENE DEBUG:
          Scene name: {{ scene_name }}
          Scene name processed: {{ scene_name | replace(' ', '_') | lower }}
          Notification ID: scene_{{ scene_name | replace(' ', '_') | lower }}
          Full entity ID: persistent_notification.scene_{{ scene_name | replace(' ', '_') | lower }}
          Scene data: {{ scene_data | to_json }}
          Scene data length: {{ scene_data | length }}
          Has light entities: {{ scene_data.keys() | select('match', '^light\\.') | list | count > 0 }}
          Has cover entities: {{ scene_data.keys() | select('match', '^cover\\.') | list | count > 0 }}
        level: info
    
    # Store the scene data
    - service: persistent_notification.create
      data:
        title: "Scene: {{ scene_name }}"
        message: "{{ scene_data | to_json }}"
        notification_id: "scene_{{ scene_name | replace(' ', '_') | lower }}"
    
    # Check if the notification was created successfully
    - variables:
        notification_entity: "persistent_notification.scene_{{ scene_name | replace(' ', '_') | lower }}"
        notification_exists: "{{ states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' }}"
    
    # Log the notification status
    - service: system_log.write
      data:
        message: >
          NOTIFICATION CREATION DEBUG:
          Notification entity: {{ notification_entity }}
          Notification exists: {{ notification_exists }}
          Notification state: {{ states(notification_entity) }}
          Notification attributes: {{ state_attr(notification_entity, 'message') if states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' else 'none' }}
        level: info
    
    # Notify user
    - service: notify.notify
      data:
        title: "Scene Saved"
        message: "Scene '{{ scene_name }}' has been saved with {{ scene_data | length }} entities"

load_scene:
  alias: "Load Saved Scene"
  description: "Loads a previously saved scene and applies it to all lights and shades"
  icon: mdi:palette
  mode: single
  fields:
    scene_name:
      name: Scene Name
      description: Name of the scene to load
      required: true
      selector:
        text:
  sequence:
    # Log detailed information for debugging
    - service: system_log.write
      data:
        message: >
          Debug info:
          scene_name defined: {{ scene_name is defined }}
          scene_name value: {{ scene_name if scene_name is defined else 'undefined' }}
        level: info
    
    # Get the notification ID - match the format used in save_scene
    - variables:
        scene_name_processed: "{{ scene_name | replace(' ', '_') | lower }}"
        notification_id: "scene_{{ scene_name | replace(' ', '_') | lower }}"
    
    # Log the notification ID for debugging
    - service: system_log.write
      data:
        message: >
          NOTIFICATION ID DEBUG:
          Scene name: {{ scene_name }}
          Scene name processed: {{ scene_name_processed }}
          Notification ID: {{ notification_id }}
          Expected entity ID: persistent_notification.{{ notification_id }}
        level: info
    
    # Create a loading notification
    - service: persistent_notification.create
      data:
        title: "Loading Scene"
        message: "Attempting to load scene: {{ scene_name }}"
        notification_id: "loading_scene"
    
    # Check if the loading notification was created successfully
    - variables:
        loading_notification_entity: "persistent_notification.loading_scene"
        loading_notification_exists: "{{ states(loading_notification_entity) != 'unknown' and states(loading_notification_entity) != 'unavailable' }}"
    
    # Log the loading notification status
    - service: system_log.write
      data:
        message: >
          LOADING NOTIFICATION DEBUG:
          Loading notification entity: {{ loading_notification_entity }}
          Loading notification exists: {{ loading_notification_exists }}
          Loading notification state: {{ states(loading_notification_entity) }}
          Loading notification attributes: {{ state_attr(loading_notification_entity, 'message') if states(loading_notification_entity) != 'unknown' and states(loading_notification_entity) != 'unavailable' else 'none' }}
        level: info
    
    # Note: We don't dismiss the notification so it can be reused
    
    # Get the scene data from the persistent notification
    - variables:
        notification_entity: "persistent_notification.{{ notification_id }}"
        # Try to find the notification directly in the states object
        notification_exists: >-
          {% set found = false %}
          {% for entity in states.persistent_notification %}
            {% if entity.entity_id == notification_entity %}
              {% set found = true %}
            {% endif %}
          {% endfor %}
          {{ found }}
    
    # Create a test notification to check if persistent notifications are working
    - service: persistent_notification.create
      data:
        title: "Test Notification"
        message: "This is a test notification"
        notification_id: "test_notification"
    
    # Check if the test notification was created successfully
    - variables:
        test_notification_entity: "persistent_notification.test_notification"
        test_notification_exists: "{{ states(test_notification_entity) != 'unknown' and states(test_notification_entity) != 'unavailable' }}"
    
    # Log the test notification status
    - service: system_log.write
      data:
        message: >
          TEST NOTIFICATION DEBUG:
          Test notification entity: {{ test_notification_entity }}
          Test notification exists: {{ test_notification_exists }}
          Test notification state: {{ states(test_notification_entity) }}
          Test notification attributes: {{ state_attr(test_notification_entity, 'message') if states(test_notification_entity) != 'unknown' and states(test_notification_entity) != 'unavailable' else 'none' }}
        level: info
    
    # Log notification entity state
    - service: system_log.write
      data:
        message: >
          NOTIFICATION DEBUG:
          Notification ID: {{ notification_id }}
          Notification entity: {{ notification_entity }}
          Notification state: {{ states(notification_entity) }}
          Notification exists (state check): {{ states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' }}
          Notification exists (direct check): {{ notification_exists }}
          All persistent notifications: {{ states.persistent_notification | map(attribute='entity_id') | list }}
          All notification IDs: {{ states.persistent_notification | map(attribute='entity_id') | map('replace', 'persistent_notification.', '') | list }}
          Notification attributes: {{ state_attr(notification_entity, 'message') if states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' else 'none' }}
        level: info
    
    # Clean up the test notification
    - service: persistent_notification.dismiss
      data:
        notification_id: "test_notification"
    
    # Try to create a notification with the same ID as the scene notification
    - service: persistent_notification.create
      data:
        title: "Test Scene Notification"
        message: "This is a test scene notification"
        notification_id: "{{ notification_id }}"
    
    # Check if the scene notification was created successfully
    - variables:
        scene_notification_exists_after_recreation: "{{ states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' }}"
    
    # Log the scene notification status
    - service: system_log.write
      data:
        message: >
          SCENE NOTIFICATION RECREATION DEBUG:
          Scene notification entity: {{ notification_entity }}
          Scene notification exists after recreation: {{ scene_notification_exists_after_recreation }}
          Scene notification state: {{ states(notification_entity) }}
          Scene notification attributes: {{ state_attr(notification_entity, 'message') if states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' else 'none' }}
        level: info
    
    # Try to access the notification by various methods
    - variables:
        direct_notification_message: >-
          {% set message = '' %}
          {% for notification in states.persistent_notification %}
            {% if notification.entity_id == notification_entity %}
              {% set message = notification.attributes.message %}
            {% endif %}
          {% endfor %}
          {{ message }}
        
        # Try to find the notification by exact title
        title_notification_message: >-
          {% set message = '' %}
          {% for notification in states.persistent_notification %}
            {% if notification.attributes.title == 'Scene: ' ~ scene_name %}
              {% set message = notification.attributes.message %}
            {% endif %}
          {% endfor %}
          {{ message }}
        
        # Try to find the notification by partial title match
        partial_title_notification_message: >-
          {% set message = '' %}
          {% for notification in states.persistent_notification %}
            {% if notification.attributes.title is defined and scene_name in notification.attributes.title %}
              {% set message = notification.attributes.message %}
            {% endif %}
          {% endfor %}
          {{ message }}
        
        # List all notification titles for debugging
        all_notification_titles: >-
          {% set titles = [] %}
          {% for notification in states.persistent_notification %}
            {% if notification.attributes.title is defined %}
              {% set titles = titles + [notification.attributes.title] %}
            {% endif %}
          {% endfor %}
          {{ titles }}
        
        # Try to find any notification that contains scene data
        any_scene_notification: >-
          {% set message = '' %}
          {% for notification in states.persistent_notification %}
            {% if notification.attributes.message is defined and notification.attributes.message | trim != '' %}
              {% if '"light.' in notification.attributes.message or '"cover.' in notification.attributes.message %}
                {% set message = notification.attributes.message %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ message }}
        
        # Try to find any notification that contains the scene name in the message
        scene_name_in_message_notification: >-
          {% set message = '' %}
          {% for notification in states.persistent_notification %}
            {% if notification.attributes.message is defined and notification.attributes.message | trim != '' %}
              {% if scene_name in notification.attributes.message %}
                {% set message = notification.attributes.message %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ message }}
        
        # Try to find any notification with an ID that contains the scene name
        scene_name_in_id_notification: >-
          {% set message = '' %}
          {% set scene_name_lower = scene_name | lower %}
          {% for entity_id in states.persistent_notification | map(attribute='entity_id') %}
            {% set notification_id = entity_id | replace('persistent_notification.', '') %}
            {% if scene_name_lower in notification_id %}
              {% set message = state_attr(entity_id, 'message') %}
            {% endif %}
          {% endfor %}
          {{ message }}
    
    # Get the raw scene data
    - variables:
        scene_data_raw: >-
          {% if scene_notification_exists_after_recreation %}
            {{ state_attr(notification_entity, 'message') }}
          {% elif states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' %}
            {{ state_attr(notification_entity, 'message') }}
          {% elif direct_notification_message | trim != '' %}
            {{ direct_notification_message }}
          {% elif title_notification_message | trim != '' %}
            {{ title_notification_message }}
          {% elif partial_title_notification_message | trim != '' %}
            {{ partial_title_notification_message }}
          {% elif scene_name_in_message_notification | trim != '' %}
            {{ scene_name_in_message_notification }}
          {% elif scene_name_in_id_notification | trim != '' %}
            {{ scene_name_in_id_notification }}
          {% elif any_scene_notification | trim != '' %}
            {{ any_scene_notification }}
          {% else %}
            {}
          {% endif %}
    
    # Log direct notification access
    - service: system_log.write
      data:
        message: >
          NOTIFICATION ACCESS DEBUG:
          Direct notification message: {{ direct_notification_message }}
          Direct notification message length: {{ direct_notification_message | length if direct_notification_message is defined else 0 }}
          Direct notification message type: {{ direct_notification_message | type_of }}
          Title notification message: {{ title_notification_message }}
          Title notification message length: {{ title_notification_message | length if title_notification_message is defined else 0 }}
          Title notification message type: {{ title_notification_message | type_of }}
          Partial title notification message: {{ partial_title_notification_message }}
          Partial title notification message length: {{ partial_title_notification_message | length if partial_title_notification_message is defined else 0 }}
          Any scene notification: {{ any_scene_notification | truncate(100) }}
          Any scene notification length: {{ any_scene_notification | length if any_scene_notification is defined else 0 }}
          Scene name in message notification: {{ scene_name_in_message_notification | truncate(100) }}
          Scene name in message notification length: {{ scene_name_in_message_notification | length if scene_name_in_message_notification is defined else 0 }}
          Scene name in ID notification: {{ scene_name_in_id_notification | truncate(100) }}
          Scene name in ID notification length: {{ scene_name_in_id_notification | length if scene_name_in_id_notification is defined else 0 }}
          All notification titles: {{ all_notification_titles }}
        level: info
    
    # Log raw scene data
    - service: system_log.write
      data:
        message: >
          RAW DATA DEBUG:
          Scene notification exists after recreation: {{ scene_notification_exists_after_recreation }}
          Raw scene data: {{ scene_data_raw }}
          Raw scene data type: {{ scene_data_raw | type_of }}
          Raw scene data length: {{ scene_data_raw | length if scene_data_raw is defined else 0 }}
          Has quotes: {{ has_quotes }}
          Is JSON: {{ scene_data_raw is string and (scene_data_raw | trim).startswith('{') and (scene_data_raw | trim).endswith('}') }}
          First 10 chars: {{ scene_data_raw[:10] if scene_data_raw is string and scene_data_raw | length > 10 else scene_data_raw }}
          Last 10 chars: {{ scene_data_raw[-10:] if scene_data_raw is string and scene_data_raw | length > 10 else scene_data_raw }}
          Contains light entities: {{ '"light.' in scene_data_raw if scene_data_raw is string else false }}
          Contains cover entities: {{ '"cover.' in scene_data_raw if scene_data_raw is string else false }}
          Data source: {% if scene_notification_exists_after_recreation %}recreated notification{% elif states(notification_entity) != 'unknown' and states(notification_entity) != 'unavailable' %}original notification{% elif direct_notification_message | trim != '' %}direct access{% elif title_notification_message | trim != '' %}title match{% elif partial_title_notification_message | trim != '' %}partial title match{% elif scene_name_in_message_notification | trim != '' %}scene name in message{% elif scene_name_in_id_notification | trim != '' %}scene name in ID{% elif any_scene_notification | trim != '' %}any scene data{% else %}none{% endif %}
        level: info
    
    # Parse the scene data - handle quotes properly
    - variables:
        # First, remove any surrounding quotes if present
        has_quotes: "{{ scene_data_raw and scene_data_raw != '{}' and scene_data_raw[0] == '\"' and scene_data_raw[-1] == '\"' }}"
        scene_data_clean: >-
          {% if scene_data_raw and scene_data_raw != '{}' %}
            {% if scene_data_raw[0] == '"' and scene_data_raw[-1] == '"' %}
              {{ scene_data_raw[1:-1] }}
            {% else %}
              {{ scene_data_raw }}
            {% endif %}
          {% else %}
            {}
          {% endif %}
        # Then parse the JSON with error handling
        scene_data: >-
          {% try %}
            {% if scene_data_clean and scene_data_clean != '{}' %}
              {{ scene_data_clean | from_json }}
            {% else %}
              {}
            {% endif %}
          {% except %}
            {% set error = exception() %}
            {{ log('JSON parsing error: ' ~ error, level='error') }}
            {}
          {% endtry %}
    
    # Log the cleaned scene data for debugging
    - service: system_log.write
      data:
        message: >
          CLEANED DATA DEBUG:
          Scene data clean: {{ scene_data_clean }}
          Scene data clean type: {{ scene_data_clean | type_of }}
          Scene data clean length: {{ scene_data_clean | length if scene_data_clean is defined else 0 }}
          First 10 chars: {{ scene_data_clean[:10] if scene_data_clean is string and scene_data_clean | length > 10 else scene_data_clean }}
          Last 10 chars: {{ scene_data_clean[-10:] if scene_data_clean is string and scene_data_clean | length > 10 else scene_data_clean }}
          Is valid JSON: {{ scene_data_clean is string and (scene_data_clean | trim).startswith('{') and (scene_data_clean | trim).endswith('}') }}
          Contains light entities: {{ '"light.' in scene_data_clean if scene_data_clean is string else false }}
          Contains cover entities: {{ '"cover.' in scene_data_clean if scene_data_clean is string else false }}
        level: info
    
    # Log the parsed scene data for debugging
    - service: system_log.write
      data:
        message: >
          PARSED DATA DEBUG:
          Scene data type: {{ scene_data | type_of }}
          Retrieved scene data for '{{ scene_name }}': {{ scene_data | length }} entities
          First few keys: {% for key in scene_data.keys() | list | slice(0, 5) %}{{ key }}, {% endfor %}
          Has light entities: {{ scene_data.keys() | select('match', '^light\\.') | list | count > 0 }}
          Has cover entities: {{ scene_data.keys() | select('match', '^cover\\.') | list | count > 0 }}
          Light entities count: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities count: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
        level: info
    
    # Process all lights in the scene data
    - repeat:
        for_each: "{{ states.light | map(attribute='entity_id') | list }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              # Check if the entity is in the scene data using a simpler approach
              entity_in_scene_data: "{{ entity_id in scene_data }}"
              # Get the entity state
              entity_state: >-
                {% if entity_in_scene_data %}
                  {{ scene_data[entity_id] }}
                {% else %}
                  missing
                {% endif %}
          
          # Log the light state for debugging
          - service: system_log.write
            data:
              message: >
                LIGHT DEBUG:
                Entity: {{ entity_id }}
                In scene data: {{ entity_in_scene_data }}
                Scene data keys (first 5): {% for key in scene_data.keys() | list | slice(0, 5) %}{{ key }}, {% endfor %}
                Entity state: {{ entity_state }}
                Condition 1 (turn on): {{ entity_state != 'missing' and entity_state | int > 0 }}
                Condition 2 (turn off): {{ entity_state != 'missing' and entity_state | int == 0 }}
              level: info
          
          # Apply the light state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state != 'missing' and entity_state | int > 0 }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      brightness_pct: "{{ entity_state }}"
                  - service: system_log.write
                    data:
                      message: "Turning ON {{ entity_id }} with brightness {{ entity_state }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state != 'missing' and entity_state | int == 0 }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Turning OFF {{ entity_id }}"
                      level: info
    
    # Process all covers in the scene data
    - repeat:
        for_each: "{{ states.cover | map(attribute='entity_id') | list }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              # Check if the entity is in the scene data using a different approach
              entity_in_scene_data: "{{ entity_id in scene_data }}"
              # Get the entity state
              entity_state: >-
                {% if entity_in_scene_data %}
                  {{ scene_data[entity_id] }}
                {% else %}
                  missing
                {% endif %}
          
          # Log the cover state for debugging
          - service: system_log.write
            data:
              message: >
                COVER DEBUG:
                Entity: {{ entity_id }}
                In scene data: {{ entity_in_scene_data }}
                Scene data keys (first 5): {% for key in scene_data.keys() | list | slice(0, 5) %}{{ key }}, {% endfor %}
                Entity state: {{ entity_state }}
                Condition 1 (open): {{ entity_state != 'missing' and entity_state | int >= 75 }}
                Condition 2 (close): {{ entity_state != 'missing' and entity_state | int <= 25 }}
                Condition 3 (position): {{ entity_state != 'missing' and entity_state | int > 25 and entity_state | int < 75 }}
              level: info
          
          # Apply the cover state - skip group covers to avoid errors
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_id.endswith('_2') or entity_id.endswith('_3') }}"
                sequence:
                  - service: system_log.write
                    data:
                      message: "Skipping group cover {{ entity_id }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state != 'missing' and entity_state | int >= 75 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Opening cover {{ entity_id }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state != 'missing' and entity_state | int <= 25 }}"
                sequence:
                  - service: cover.close_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Closing cover {{ entity_id }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state != 'missing' and entity_state | int > 25 and entity_state | int < 75 }}"
                sequence:
                  - service: cover.set_cover_position
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      position: "{{ entity_state }}"
                  - service: system_log.write
                    data:
                      message: "Setting cover {{ entity_id }} position to {{ entity_state }}"
                      level: info
    
    # Notify user
    - service: notify.notify
      data:
        title: "Scene Loaded"
        message: "Scene '{{ scene_name }}' has been loaded"

# Helper script to process lights
process_scene_lights:
  alias: "Process Scene Lights"
  mode: parallel
  sequence:
    - variables:
        light_entities: >
          {% set all_lights = states.light | map(attribute='entity_id') | list %}
          {{ all_lights }}
    
    # Process each light
    - repeat:
        for_each: "{{ light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] if entity_id in scene_data else 'skip' }}"
          
          # Skip if not in scene data
          - condition: template
            value_template: "{{ entity_state != 'skip' }}"
          
          # Turn on or off based on state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int > 0 }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      brightness_pct: "{{ entity_state }}"
            default:
              - service: light.turn_off
                target:
                  entity_id: "{{ entity_id }}"

# Helper script to process covers
process_scene_covers:
  alias: "Process Scene Covers"
  mode: parallel
  sequence:
    - variables:
        cover_entities: >
          {% set all_covers = states.cover | map(attribute='entity_id') | list %}
          {{ all_covers }}
    
    # Process each cover
    - repeat:
        for_each: "{{ cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] if entity_id in scene_data else 'skip' }}"
          
          # Skip if not in scene data
          - condition: template
            value_template: "{{ entity_state != 'skip' }}"
          
          # Open or close based on state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int >= 75 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int <= 25 }}"
                sequence:
                  - service: cover.close_cover
                    target:
                      entity_id: "{{ entity_id }}"
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int > 25 and entity_state | int < 75 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
