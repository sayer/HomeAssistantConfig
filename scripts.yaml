change_timezone:
  alias: Change System Timezone
  description: "Change Home Assistant timezone via configuration file"
  fields:
    timezone:
      description: "New timezone to set"
      example: "America/New_York"
      selector:
        select:
          options:
            - "America/New_York"
            - "America/Chicago"
            - "America/Denver"
            - "America/Los_Angeles"
            - "America/Anchorage"
            - "Pacific/Honolulu"
            - "America/Phoenix"
            - "America/Indiana/Indianapolis"
            - "America/Detroit"
            - "America/Kentucky/Louisville"
            - "America/Boise"
            - "America/Regina"
            - "America/Winnipeg"
            - "America/Toronto"
            - "America/Vancouver"
            - "America/Edmonton"
            - "America/Calgary"
            - "America/Montreal"
            - "America/Halifax"
            - "America/St_Johns"
  sequence:
    - service: shell_command.change_timezone
      data:
        timezone: "{{ timezone }}"
    - delay:
        seconds: 2
    - service: persistent_notification.create
      data:
        title: "Timezone Changed"
        message: "System timezone has been changed to {{ timezone }}. Home Assistant will restart in 10 seconds to apply changes."
    - service: script.notify_home
      data:
        title: "Timezone Changed"
        message: "System timezone changed to {{ timezone }}. Restarting Home Assistant..."
    - delay:
        seconds: 10
    - service: homeassistant.restart
  mode: single
  icon: mdi:clock-time-four

auto_detect_timezone:
  alias: Auto-Detect Timezone from Location
  description: "Automatically detect and set timezone based on current GPS location"
  sequence:
    - condition: template
      value_template: >
        {{ states('sensor.gps_127_0_0_1_latitude') not in ['unknown', 'unavailable', 'none'] and
           states('sensor.gps_127_0_0_1_longitude') not in ['unknown', 'unavailable', 'none'] }}
    - service: persistent_notification.create
      data:
        title: "Detecting Timezone"
        message: "Detecting timezone for current location..."
    - delay:
        seconds: 3
    - service: homeassistant.update_entity
      target:
        entity_id: sensor.location_timezone
    - delay:
        seconds: 2
    - condition: template
      value_template: >
        {{ states('sensor.location_timezone') not in ['unknown', 'unavailable', 'none'] and
           states('sensor.location_timezone') != states('input_select.timezone') }}
    - service: input_select.select_option
      target:
        entity_id: input_select.timezone
      data:
        option: "{{ states('sensor.location_timezone') }}"
    - service: persistent_notification.create
      data:
        title: "Timezone Auto-Detected"
        message: "Detected timezone: {{ states('sensor.location_timezone') }}. Setting system timezone..."
    - service: script.notify_home
      data:
        title: "Timezone Auto-Detected"
        message: "Detected timezone: {{ states('sensor.location_timezone') }}"
  mode: single
  icon: mdi:map-marker-clock

store_bus:
  alias: Store Bus
  sequence:
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_pump
      - switch.heat
      - switch.air_conditioning
  - service: notify.notify
    data:
      message: Foretravel has been stored
      title: Foretravel Stored
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.floor_heat_1
      - switch.floor_heat_2
      - switch.floor_heat_3
      - switch.water_autofill
      - switch.water_pump
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
  - delay:
      hours: 0
      minutes: 2
      seconds: 0
      milliseconds: 0
  - service: lock.lock
    data: {}
    target:
      entity_id: lock.locks
  - service: cover.close_cover
    data: {}
    target:
      entity_id: cover.all_night_shades
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Bus is being stored.
  - service: input_boolean.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: input_boolean.storage
  mode: single
good_night:
  alias: Good Night
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id: light.all_ceiling_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id: light.exterior_lights
    action: light.turn_off
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - light.all_lights
      - light.entry_light_2
    action: light.turn_off
  - data: {}
    target:
      entity_id: lock.locks
    action: lock.lock
  - data: {}
    target:
      entity_id: cover.all_night_shades
    action: cover.close_cover
  - data: {}
    target:
      entity_id:
      - switch.auto_gen
      - switch.auto_gen_5
    action: homeassistant.turn_on
  mode: single
good_morning:
  alias: Good Morning
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.dimmer_3_19
      - light.cockpit_accents
      - light.living_room_accents
      - light.rear_bath_accent
      - light.dimmer_3_10
      - light.entry_light_2
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 5
      seconds: 0
      milliseconds: 0
  - data: {}
    target:
      entity_id:
      - cover.windshield_night
      - cover.d_s_living_room_night
      - cover.dinette_night
    action: cover.open_cover
  mode: single
evening:
  alias: Evening
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - condition: state
    entity_id: input_boolean.camping
    state: 'on'
  - data: {}
    target:
      entity_id:
      - light.exterior_accents
      - light.interior_accents
      - light.porch_handle
      - light.awning_lights
    action: light.turn_on
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data: {}
    target:
      entity_id: cover.all_day_shades
    action: cover.close_cover
  mode: single
  icon: mdi:clock-time-seven
tv_time:
  alias: TV Time
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 5
      seconds: 0
  - service: light.turn_on
    data: {}
    target:
      entity_id:
      - light.interior_accents
    enabled: false
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 1
      seconds: 0
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id:
      - light.cockpit_accents
      - light.living_room_accents
  - service: cover.close_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.living_night_shades
  mode: single
  icon: mdi:television

drive_time:
  alias: Drive Time
  sequence:
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.cockpit_night_shades
      - cover.cockpit_day_shades
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_ceiling_lights
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.exterior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 1
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.interior_accents
  - delay:
      hours: 0
      minutes: 0
      seconds: 2
      milliseconds: 0
  - service: light.turn_off
    data: {}
    target:
      entity_id: light.all_lights
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - switch.black_waste_dump
      - switch.gray_water_bypass
      - switch.water_autofill
      - switch.water_pump
  - service: fan.turn_off
    data: {}
    target:
      entity_id: fan.fans
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id:
      - media_player.tv_samsung_6_series_50
      - media_player.samsung_6_series_50
  - service: homeassistant.turn_off
    data: {}
    target:
      entity_id: input_boolean.camping
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id:
      - light.dimmer_3_14
      - light.entry_light_2
  - service: timer.start
    data: {}
    target:
      entity_id: timer.setlocationtimer
  - service: tts.cloud_say
    data:
      cache: true
      entity_id: media_player.bedroom_2
      message: Drive time!
  - service: input_boolean.turn_off
    metadata: {}
    data: {}
    target:
      entity_id:
      - input_boolean.storage
      - input_boolean.camping
  - service: switch.turn_on
    metadata: {}
    data: {}
    target:
      entity_id: switch.ac_4
  mode: single
  icon: mdi:steering
all_bright:
  alias: All Bright
  sequence:
  - condition: state
    entity_id: input_boolean.busparked
    state: 'on'
    for:
      hours: 0
      minutes: 1
      seconds: 0
  - service: homeassistant.turn_on
    data: {}
    target:
      entity_id: light.all_lights
  - service: cover.open_cover
    data: {}
    target:
      entity_id:
      - cover.all_day_shades
      - cover.all_night_shades
  mode: single
  icon: mdi:weather-sunny
set_current_location_as_home:
  alias: Set Current location as home
  sequence:
  - condition: state
    entity_id: sensor.gps_127_0_0_1_latitude
    state: '{% if sensor.latitude | is_number %}'
    enabled: false
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    enabled: false
    action: homeassistant.set_location
  - data:
      latitude: '{{ states(''sensor.gps_127_0_0_1_latitude'') | float }}'
      longitude: '{{ states(''sensor.gps_127_0_0_1_longitude'') | float }}'
    action: homeassistant.set_location
  mode: single
notify_iphone:
  alias: Notify iPhone
  sequence:

  - data:
      message: '{{message}}'
      title: '{{title}} — {{ states(''input_number.coach_number'') | int }}'
    action: notify.mobile_app_iphone_15_pro_max
  mode: single
  fields:
    title:
      selector:
        text:
      name: Title
      default: Foretravel
    message:
      selector:
        text:
      name: Message
tts_alert:
  alias: TTS alert
  sequence:
  - service: media_player.play_media
    target:
      entity_id:
      - media_player.kitchen
      - media_player.bedroom_2
    data:
      media_content_id: media-source://media_source/local/f1-radio-notification.mp3
      media_content_type: audio/mpeg
    metadata:
      title: f1-radio-notification.mp3
      thumbnail:
      media_class: music
      children_media_class:
      navigateIds:
      - {}
      - media_content_type: app
        media_content_id: media-source://media_source
  - service: tts.speak
    data:
      cache: true
      message: '{{message}}'
      media_player_entity_id: media_player.kitchen,media_player.bedroom_2
    target:
      entity_id: tts.piper
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
notify_home:
  alias: Notify Home
  sequence:
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.notify_iphone
  - data:
      message: '{{message}}'
      title: '{{title}}'
    action: script.tts_alert
  - data:
      title: '{{title}}'
      message: '{{message}}'
    action: notify.persistent_notification
  mode: single
  fields:
    message:
      selector:
        text:
      name: Message
      required: true
    title:
      selector:
        text:
      name: Title
      default: Foretravel
ai_analyze_dash_video:
  alias: AI - Analyze Dash Video
  sequence:
  - data:
      filename: /config/www/snapshot_dash.jpg
    action: camera.snapshot
    target:
      device_id: eea91240afc6576d615f0b18aa1ec28e
  - action: llmvision.stream_analyzer
    data:
      remember: false
      duration: 5
      max_frames: 3
      include_filename: false
      target_width: 1280
      detail: low
      max_tokens: 100
      temperature: 0.2
      expose_images: false
      provider: 01JDN5XHDWG1Q8TJ5718TYR6EE
      message: Analyze and describe the image. Highlight any people or vehicles. Keep
        the resonse to 128 characters.
      image_entity:
      - camera.g5_flex_high_resolution_channel
    response_variable: response
  - delay:
      hours: 0
      minutes: 0
      seconds: 5
      milliseconds: 0
  - data:
      message: 'Response received: {{ response.response_text }}'
    action: system_log.write
  - condition: template
    value_template: '{{ response.response_text is not none and response.response_text
      | length > 0 }}'
  - data:
      value: '{{ response.response_text }}'
    target:
      entity_id: input_text.llmvision_response
    action: input_text.set_value
  - action: notify.mobile_app_iphone_15_pro_max
    metadata: {}
    data:
      title: Foretravel - Dash
      message: '{{ response.response_text }}'
      data:
        image: http://192.168.100.175:8123/local/snapshot_dash.jpg
        content-type: image/jpeg
        hide-thumbnail: false
  description: Analyzes the dash video and updates input_text with the response.
  icon: mdi:cube-scan


lock_all_cargo_doors:
  alias: "Lock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.lock
              target:
                entity_id: lock.cargo_door_lock_all
      default:

        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_0
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.lock
          target:
            entity_id: lock.cargo_door_lock_4

unlock_all_cargo_doors:
  alias: "Unlock All Cargo Doors with Delay"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: >
                {{ states.lock.cargo_door_lock_all is defined and states.lock.cargo_door_lock_all.state in ['locked', 'unlocked'] }}
          sequence:
            - service: lock.unlock
              target:
                entity_id: lock.cargo_door_lock_all
      default:
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_0
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_1
        - delay: "00:00:02"
        - service: lock.unlock  
          target:
            entity_id: lock.cargo_door_lock_2
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_3
        - delay: "00:00:02"
        - service: lock.unlock
          target:
            entity_id: lock.cargo_door_lock_4

# Generator Shutdown with Verification Script
generator_shutdown_with_verification:
  alias: "Generator Shutdown with Verification"
  description: "Turn off generator after specified minutes, verify shutdown, retry if needed, and notify on failure"
  fields:
    delay_minutes:
      description: "Number of minutes to wait before shutting down generator"
      example: 30
      required: true
      selector:
        number:
          min: 1
          max: 480
          step: 1
          unit_of_measurement: "minutes"
    notification_service:
      description: "Notification service to use for alerts"
      example: "notify.mobile_app"
      required: false
      default: "notify.mobile_app"
      selector:
        text:
  sequence:
    # Wait for the specified delay
    - delay:
        minutes: 30
    
    # Turn off generator
    - service: switch.turn_off
      target:
        entity_id: switch.generator
      
    # Wait 30 seconds for generator to shut down
    - delay:
        seconds: 30
    
    # Check if generator is off, retry up to 3 times
    - repeat:
        count: 3
        sequence:
          # Check if generator is still running
          - condition: template
            value_template: "{{ is_state('switch.generator', 'on') }}"
          # If still running, turn off again
          - service: switch.turn_off
            target:
              entity_id: switch.generator
            
          # Wait 30 seconds before next check
          - delay:
              seconds: 30
    
    # Final verification - if still running, send notification
    - condition: template
      value_template: "{{ is_state('switch.generator', 'on') }}"
    - service: "{{ notification_service }}"
      data:
        title: "Generator Shutdown Failed"
        message: "Unable to stop generator after {{ delay_minutes }} minutes and 3 retry attempts. Manual intervention required."
        data:
          priority: "high"
          channel: "alerts"

# Generator Start with Verification Script
generator_start_with_verification:
  alias: "Generator Start with Verification"
  description: "Turn on generator after specified minutes, verify startup, retry if needed, and notify on failure"
  fields:
    delay_minutes:
      description: "Number of minutes to wait before starting generator"
      example: 5
      required: true
      selector:
        number:
          min: 1
          max: 480
          step: 1
          unit_of_measurement: "minutes"
    notification_service:
      description: "Notification service to use for alerts"
      example: "notify.mobile_app"
      required: false
      default: "notify.mobile_app"
      selector:
        text:
  sequence:
    # Wait for the specified delay
    - delay:
        minutes: 30
    
    # Turn on generator
    - service: switch.turn_on
      target:
        entity_id: switch.generator
    
    # Wait 30 seconds for generator to start
    - delay:
        seconds: 30
    
    # Check if generator is on, retry up to 3 times
    - repeat:
        count: 3
        sequence:
          # Check if generator is still off
          - condition: template
            value_template: "{{ is_state('switch.generator', 'off') }}"
          # If still off, turn on again
          - service: switch.turn_on
            target:
              entity_id: switch.generator
          # Wait 60 seconds before next check
          - delay:
              seconds: 60
    
    # Final verification - if still off, send notification
    - condition: template
      value_template: "{{ is_state('switch.generator', 'off') }}"
    - service: "{{ notification_service }}"
      data:
        title: "Generator Startup Failed"
        message: "Unable to start generator after {{ delay_minutes }} minutes and 3 retry attempts. Manual intervention required."
        data:
          priority: "high"
          channel: "alerts"

save_scene:
  alias: "Save Current Scene"
  description: "Saves the current state of all lights and shades as a scene with the given name"
  fields:
    scene_name:
      name: Scene Name
      description: Name to save this scene as
      required: true
      selector:
        text:
  sequence:
    # Filter light entities - exclude groups (entities with entity_id attribute)
    - variables:
        all_light_entities: >-
          {% set all_lights = states.light | map(attribute='entity_id') | list %}
          {{ all_lights }}
        light_groups: >-
          {% set groups = states.light
             | selectattr('attributes.entity_id', 'defined')
             | map(attribute='entity_id') | list %}
          {{ groups }}
        light_entities: >-
          {% set real_lights = states.light
             | selectattr('attributes.entity_id', 'undefined')
             | map(attribute='entity_id') | list %}
          {{ real_lights }}
    
    # Log light filtering results
    - service: system_log.write
      data:
        message: >
          SAVE SCENE DEBUG - Light Filtering:
          Total light entities: {{ all_light_entities | length }}
          Light groups (excluded): {{ light_groups | length }}
          Real lights (included): {{ light_entities | length }}
          
          All lights: {{ all_light_entities }}
          Light groups: {{ light_groups }}
          Real lights: {{ light_entities }}
        level: info
    
    # Filter cover entities - exclude groups (entities with entity_id attribute)
    - variables:
        all_cover_entities: >-
          {% set all_covers = states.cover | map(attribute='entity_id') | list %}
          {{ all_covers }}
        # Detect cover groups dynamically based on attributes
        cover_groups: >-
          {% set groups = [] %}
          {% for entity in states.cover %}
            {# Check if entity has 'entity_id' attribute (indicates it's a group) #}
            {% if entity.attributes.entity_id is defined %}
              {% set _ = groups.append(entity.entity_id) %}
            {# Also check for position_template attribute which template groups have #}
            {% elif entity.attributes.position_template is defined %}
              {% set _ = groups.append(entity.entity_id) %}
            {% endif %}
          {% endfor %}
          {{ groups }}
        cover_entities: >-
          {% set all_covers = states.cover | map(attribute='entity_id') | list %}
          {% set real_covers = [] %}
          {% for entity_id in all_covers %}
            {% if entity_id not in cover_groups %}
              {% set _ = real_covers.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ real_covers }}
        scene_data: {}
    
    # Log cover filtering results
    - service: system_log.write
      data:
        message: >
          SAVE SCENE DEBUG - Cover Filtering:
          Total cover entities: {{ all_cover_entities | length }}
          Cover groups (excluded): {{ cover_groups | length }}
          Real covers (included): {{ cover_entities | length }}
          
          All covers: {{ all_cover_entities }}
          Cover groups: {{ cover_groups }}
          Real covers: {{ cover_entities }}
        level: info
    
    # Process all lights
    - repeat:
        for_each: "{{ light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'on') else 0 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Process all covers/shades
    - repeat:
        for_each: "{{ cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ 100 if is_state(repeat.item, 'open') else
                                0 if is_state(repeat.item, 'closed') else
                                75 if is_state(repeat.item, 'opening') else
                                25 if is_state(repeat.item, 'closing') else
                                50 }}"
          - variables:
              scene_data: "{{ dict(scene_data, **{repeat.item: entity_state}) }}"
    
    # Store the scene data using MQTT
    - variables:
        mqtt_topic: "homeassistant/scenes/{{ scene_name | replace(' ', '_') | lower }}"
        # Create a simple string format: entity_id=value|entity_id=value|...
        simple_data: >-
          {% for entity_id, state in scene_data.items() %}{{ entity_id }}={{ state }}{% if not loop.last %}|{% endif %}{% endfor %}
    
    # Log the data we're storing with detailed breakdown
    - service: system_log.write
      data:
        message: >
          SAVE SCENE - MQTT DATA:
          Scene name: {{ scene_name }}
          MQTT topic: {{ mqtt_topic }}
          Total entities in scene_data: {{ scene_data | length }}
          Light entities in scene_data: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities in scene_data: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
          
          Light entities saved: {{ scene_data.keys() | select('match', '^light\\.') | list }}
          Cover entities saved: {{ scene_data.keys() | select('match', '^cover\\.') | list }}
          
          String length: {{ simple_data | length }} characters
          First 500 chars: {{ simple_data[:500] }}
        level: info
    
    # Publish scene data to MQTT with retain flag
    - service: mqtt.publish
      data:
        topic: "{{ mqtt_topic }}"
        payload: "{{ simple_data }}"
        retain: true
    
    # Wait a moment for MQTT to process
    - delay:
        seconds: 2
    
    # Verify the scene was saved by checking the corresponding sensor entity
    - variables:
        sensor_entity: "sensor.scene_{{ scene_name | replace(' ', '_') | lower }}"
        saved_data: "{{ state_attr(sensor_entity, 'data') }}"
        save_successful: "{{ saved_data != none and saved_data is defined and saved_data | length > 0 }}"
    
    # Log the verification result
    - service: system_log.write
      data:
        message: >
          SAVE SCENE VERIFICATION:
          Scene name: {{ scene_name }}
          Sensor entity: {{ sensor_entity }}
          Save successful: {{ save_successful }}
          Saved data length: {{ saved_data | length if saved_data is defined and saved_data != none else 0 }} characters
          Original data length: {{ simple_data | length }} characters
          Data matches: {{ saved_data == simple_data if save_successful else false }}
        level: info
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          SAVE SCENE:
          Scene name: {{ scene_name }}
          Scene data length: {{ scene_data | length }} entities
          Light entities: {{ scene_data.keys() | select('match', '^light\\.') | list | count }}
          Cover entities: {{ scene_data.keys() | select('match', '^cover\\.') | list | count }}
        level: info
    
    # Notify user with verification status
    - service: notify.notify
      data:
        title: "Scene {{ 'Saved Successfully' if save_successful else 'Save Failed' }}"
        message: >
          Scene '{{ scene_name }}' {{ 'has been saved with ' + (scene_data | length | string) + ' entities and verified in MQTT' if save_successful else 'failed to save to MQTT - check logs for details' }}

load_scene:
  alias: "Load Saved Scene"
  description: "Loads a previously saved scene and applies it to all lights and shades"
  icon: mdi:palette
  mode: single
  variables:
    scene_clean: "{{ scene_name | replace(' ', '_') | lower }}"
    sensor_entity: "sensor.scene_{{ scene_clean }}"
    # Initialize list to track which shades have been commanded
    commanded_shades: []
  fields:
    scene_name:
      name: Scene Name
      description: Name of the scene to load
      required: true
      selector:
        text:
  sequence:
    # Log scene load attempt
    - service: system_log.write
      data:
        message: "Loading scene: {{ scene_name }}"
        level: info
    
    - variables:
        scene_data_raw: "{{ state_attr(sensor_entity, 'data') }}"
        scene_data_simple: "{{ scene_data_raw.data if scene_data_raw is mapping and 'data' in scene_data_raw else scene_data_raw }}"
    
    # Log the scene data
    - service: system_log.write
      data:
        message: >
          LOAD SCENE:
          Scene name: {{ scene_name }}
          MQTT sensor entity: {{ sensor_entity }}
          Scene data exists: {{ scene_data_raw != none }}
          Scene data length: {{ scene_data_simple | length if scene_data_simple is defined and scene_data_simple != none else 0 }} characters
          First 200 chars: {{ scene_data_simple[:200] if scene_data_simple is defined and scene_data_simple != none else 'undefined' }}
        level: info
    
    # Parse the simple data format into a dictionary
    - variables:
        # Initialize an empty dictionary
        scene_data: {}
        # Split the string by '|' to get entity_id=value pairs
        entity_pairs: "{{ scene_data_simple.split('|') if scene_data_simple is defined and scene_data_simple != none and scene_data_simple != '' else [] }}"
    
    # Process each entity pair and add to scene_data
    - repeat:
        for_each: "{{ entity_pairs }}"
        sequence:
          - variables:
              # Split the pair by '=' to get entity_id and value
              pair_parts: "{{ repeat.item.split('=') }}"
              # Only process if we have both entity_id and value
              has_both_parts: "{{ pair_parts | length == 2 }}"
          
          # Only add to scene_data if we have valid parts
          - condition: template
            value_template: "{{ has_both_parts }}"
          - variables:
              entity_id: "{{ pair_parts[0] }}"
              entity_state: "{{ pair_parts[1] | int }}"
              # Add to scene_data dictionary
              scene_data: "{{ dict(scene_data, **{entity_id: entity_state}) }}"
    
    # Log parsing result
    - service: system_log.write
      data:
        message: >
          PARSE SCENE DATA:
          Pairs found: {{ entity_pairs | length }}
          Scene data parsed successfully: {{ scene_data is mapping }}
          Scene data keys: {{ scene_data.keys() | list | count if scene_data is mapping else 0 }}
        level: info
    
    # Process only lights that are in the scene data
    - variables:
        light_entities_in_scene: "{{ scene_data.keys() | select('match', '^light\\.') | list }}"
        filtered_light_entities: "{{ light_entities_in_scene }}"
    
    - repeat:
        for_each: "{{ filtered_light_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Apply the light state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int > 0 }}"
                sequence:
                  - service: light.turn_on
                    target:
                      entity_id: "{{ entity_id }}"
                    data:
                      brightness_pct: "{{ entity_state }}"
                  - service: system_log.write
                    data:
                      message: "Turning ON {{ entity_id }} with brightness {{ entity_state }}"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int == 0 }}"
                sequence:
                  - service: light.turn_off
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Turning OFF {{ entity_id }}"
                      level: info
    
    # Process only covers that are in the scene data
    - variables:
        cover_entities_in_scene: "{{ scene_data.keys() | select('match', '^cover\\.') | list }}"
        # Detect cover groups dynamically based on attributes
        shade_groups: >-
          {% set groups = [] %}
          {% for entity_id in cover_entities_in_scene %}
            {% set entity = states.cover[entity_id.split('.')[1]] if states.cover[entity_id.split('.')[1]] is defined else none %}
            {% if entity %}
              {# Check if entity has 'entity_id' attribute (indicates it's a group) #}
              {% if entity.attributes.entity_id is defined %}
                {% set _ = groups.append(entity_id) %}
              {# Also check for position_template attribute which template groups have #}
              {% elif entity.attributes.position_template is defined %}
                {% set _ = groups.append(entity_id) %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ groups }}
        # Only process individual shades, not groups
        filtered_cover_entities: >-
          {% set individual_shades = [] %}
          {% for entity in cover_entities_in_scene %}
            {% if entity not in shade_groups %}
              {% set _ = individual_shades.append(entity) %}
            {% endif %}
          {% endfor %}
          {{ individual_shades }}
    
    # Log filtering results
    - service: system_log.write
      data:
        message: >
          LOAD SCENE - Cover Filtering:
          Total covers in scene: {{ cover_entities_in_scene | length }}
          Individual shades to control: {{ filtered_cover_entities | length }}
          Excluded groups: {{ cover_entities_in_scene | select('in', shade_groups) | list }}
        level: info
    
    - repeat:
        for_each: "{{ filtered_cover_entities }}"
        sequence:
          - variables:
              entity_id: "{{ repeat.item }}"
              entity_state: "{{ scene_data[entity_id] }}"
          
          # Check if this shade has already been commanded
          - condition: template
            value_template: "{{ entity_id not in commanded_shades }}"
          
          # Add to commanded shades list
          - variables:
              commanded_shades: "{{ commanded_shades + [entity_id] }}"
          
          # Apply the cover state
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int >= 50 }}"
                sequence:
                  - service: cover.open_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Opening cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
              - conditions:
                  - condition: template
                    value_template: "{{ entity_state | int < 50 }}"
                sequence:
                  - service: cover.close_cover
                    target:
                      entity_id: "{{ entity_id }}"
                  - service: system_log.write
                    data:
                      message: "Closing cover {{ entity_id }} (was {{ entity_state }}%)"
                      level: info
    
    # Notify user
    - service: notify.notify
      data:
        title: "Scene Loaded"
        message: "Scene '{{ scene_name }}' has been loaded"

# Master Thermostat Control Scripts
master_thermostat_set_cool:
  alias: "Master Thermostat - Set Cool Temperature"
  description: "Set all thermostats to cool mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 72
      selector:
        number:
          min: 60
          max: 90
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: cool

master_thermostat_set_heat:
  alias: "Master Thermostat - Set Heat Temperature"
  description: "Set all thermostats to heat mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 68
      selector:
        number:
          min: 50
          max: 85
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: heat

master_thermostat_set_auto:
  alias: "Master Thermostat - Set Auto Mode"
  description: "Set all thermostats to auto mode with specified temperature"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 70
      selector:
        number:
          min: 60
          max: 85
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"
        hvac_mode: auto

master_thermostat_off:
  alias: "Master Thermostat - Turn Off"
  description: "Turn off all thermostats"
  sequence:
    - service: climate.set_hvac_mode
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        hvac_mode: off

master_thermostat_set_temperature:
  alias: "Master Thermostat - Set Temperature"
  description: "Set temperature for all thermostats based on current mode"
  fields:
    temperature:
      description: "Target temperature in Fahrenheit"
      example: 72
      selector:
        number:
          min: 50
          max: 90
          step: 1
          unit_of_measurement: "°F"
  sequence:
    - service: climate.set_temperature
      target:
        entity_id: >
          {% set thermostats = [
            'climate.livingroom_thermostat',
            'climate.kitchen_thermostat',
            'climate.bedroom_thermostat',
            'climate.bathroom_thermostat'
          ] %}
          {% set available_thermostats = [] %}
          {% for entity_id in thermostats %}
            {% if states(entity_id) not in ['unavailable', 'unknown', 'none'] %}
              {% set _ = available_thermostats.append(entity_id) %}
            {% endif %}
          {% endfor %}
          {{ available_thermostats }}
      data:
        temperature: "{{ temperature }}"

master_thermostat_set_mode:
  alias: "Master Thermostat - Set HVAC Mode"
  description: "Set HVAC mode for all thermostats"
  fields:
    hvac_mode:
      description: "HVAC mode to set"
      example: "cool"
      selector:
        select:
          options:
            - "off"
            - "heat"
            - "cool"
            - "auto"
  sequence:
    - choose:
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'off' }}"
          sequence:
            - service: script.master_thermostat_off
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'heat' }}"
          sequence:
            - service: script.master_thermostat_set_heat
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'cool' }}"
          sequence:
            - service: script.master_thermostat_set_cool
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"
        - conditions:
            - condition: template
              value_template: "{{ hvac_mode == 'auto' }}"
          sequence:
            - service: script.master_thermostat_set_auto
              data:
                temperature: "{{ state_attr('climate.master_thermostat', 'temperature') | default(72) }}"

